---
title: RSA入门小结
date: 2022-08-15 11:20:00 +0800
categories: [CTF, Crypto]
tags: [rsa]     # TAG names should always be lowercase
math: true # use \cdot instead of *
---



# 分解n

## 直接分解

素数分解问题是困难的，但是可以通过计算机进行暴力分解。

- 1999年，名为Cray的超级计算机用了5个月时间分解了512bit的n。
- 2009年，一群研究人员成功分解了768bit的n。
- 2010年，又提出了一些针对1024bit的n的分解的途径，但是没有正面分解成功。通常意义上来说，一般认为2048bit以上的n是安全的。现在一般的公钥证书都是4096bit的证书。

如果n比较小，那么可以通过工具进行直接n分解，从而得到私钥。如果n的大小小于256bit，那么我们通过本地工具即可爆破成功。例如采用windows平台的RSATool2v17，可以在几分钟内完成256bit的n的分解。

如果n在768bit或者更高，可以尝试使用一些在线的n分解网站，这些网站会存储一些已经分解成功的n，比如：http://factordb.com

针对大整数的分解有很多种算法，性能上各有优异，有Fermat方法，Pollard rho方法，试除法，以及椭圆曲线法，连分数法，二次筛选法，数域分析法等等。其中一些方法应用在RSA的攻击上也有奇效。

在p，q的取值差异过大时，我们可以采用Pollard rho方法。或者p，q的取值过于相近的时候，Fermat方法可以很快将n分解成功。

此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。

RsaCtfTool集成了更多的分解算法。

## rsa-wiener-attack

低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：

$d<\frac{1}{3}gn^\frac{1}{4}$

那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：

$q< p< 2q$

如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。

[tools](https://github.com/pablocelayes/rsa-wiener-attack)

## boneh_durfee-attack

$d< n^{0.291}$

[tools](https://github.com/mimoo/RSA-and-LLL-attacks)

## 公约数

如果在两次公钥的加密过程中使用的 $n_1$ 和 $n_2$ 具有相同的素因子，那么可以利用欧几里得算法直接将 $n_1$ 和 $n_2$ 分解。

通过欧几里得算法可以直接求出 $n_1$ 和 $n_2$ 的最大公约数p，欧几里得算法时间复杂度O(logn)这个时间复杂度即便是4096 bit也是秒破级别。

```python
'''info.txt
m = xxxxxxxx
e = 65537
========== n c ==========
n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207
c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320
...
'''
e = 65537
n = []
c = []
with open("./info.txt", "r") as f:
    for line in f.readlines():
        if line[0] == 'n':
            n.append(int(line[4:]))
        elif line[0] == 'c':
            c.append(int(line[4:]))

import libnum

for i in range(0, len(n)):
    for j in range(i+1, len(n)):
        if libnum.gcd(n[i], n[j]) != 1:
            p = n[i]//libnum.gcd(n[i], n[j])
            q = n[i]//p
            phi = (p-1)*(q-1)
            d = libnum.invmod(e, phi)
            m = pow(c[i], d, n[i])
            print(libnum.n2s(m))
            break
    else:
        continue
    break
```

## 特殊关系

枚举倍数关系

```python
e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
# dp = d mod p-1
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

# ed = 1 mod (p-1)(q-1)
# e*dp = 1 mod p-1
# (p-1)x = e*dp-1 => p-1 = (e*dp-1)/x, x<e

import libnum

x = 1
while x<e:
    if (e*dp-1)%x == 0:
        p = (e*dp-1)//x + 1
        if n%p == 0:
            d = libnum.invmod(e, (p-1)*(n//p-1))
            m = pow(c, d, n)
            print(libnum.n2s(m))
            break
    x += 1
```

解二元方程

$x^2-(p+q)x+(pq) = x^2-\frac{(npp-n-4)}{2}x+n$

```python
n = 19402643768027967294480695361037227649637514561280461352708420192197328993512710852087871986349184383442031544945263966477446685587168025154775060178782897097993949800845903218890975275725416699258462920097986424936088541112790958875211336188249107280753661467619511079649070248659536282267267928669265252935184448638997877593781930103866416949585686541509642494048554242004100863315220430074997145531929128200885758274037875349539018669336263469803277281048657198114844413236754680549874472753528866434686048799833381542018876362229842605213500869709361657000044182573308825550237999139442040422107931857506897810951
e = 65537
c = 7991219189591014572196623817385737879027208108469800802629706564258508626010674513875496029177290575819650366802730803283761137036255380767766538866086463895539973594615882321974738140931689333873106124459849322556754579010062541988138211176574621668101228531769828358289973150393343109948611583609219420213530834364837438730411379305046156670015024547263019932288989808228091601206948741304222197779808592738075111024678982273856922586615415238555211148847427589678238745186253649783665607928382002868111278077054871294837923189536714235044041993541158402943372188779797996711792610439969105993917373651847337638929
# npp = (p+2)(q+2)
npp = 19402643768027967294480695361037227649637514561280461352708420192197328993512710852087871986349184383442031544945263966477446685587168025154775060178782897097993949800845903218890975275725416699258462920097986424936088541112790958875211336188249107280753661467619511079649070248659536282267267928669265252935757418867172314593546678104100129027339256068940987412816779744339994971665109555680401467324487397541852486805770300895063315083965445098467966738905392320963293379345531703349669197397492241574949069875012089172754014231783160960425531160246267389657034543342990940680603153790486530477470655757947009682859

import libnum
# ax^2 + bx + c = 0
a = 1
b = -((npp - n - 4) // 2)
c = n
delta = libnum.nroot(b * b - 4 * a * c, 2)
x1 = (-b - delta) // 2
x2 = (-b + delta) // 2
print(x1, x2, x1 * x2 == n)
p1 = x1
q1 = x2
p2 = x1+2
q2 = x2+2
# encrypt by e with n and npp
# so decrypt by e with mod npp first
d2 = libnum.invmod(e, (p2-1) * (q2-1))
m2 = pow(c, d2, npp)
d1 = libnum.invmod(e, (p1-1) * (q1-1))
m1 = pow(m2, d1, n)
print(libnum.n2s(m1))
```

# 部分信息泄露

## Coppersmith定理攻击

Coppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于 $n^{\frac{1}{e}}$，就可以运用一个O(log n)的算法求出这些根。

这个定理可以应用于RSA算法。如果e = 3并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。


## 完全明文返回

适用情况：可以构造任意密文并获得对应明文。

这个好理解，在一个RSA加密过程中，明文为 $m$，密文为 $c$，模数为 $n$，加密指数为 $e$，选取x以满足 $gcd(x,n)==1$ 从而使 $x$ 模 $n$ 的逆存在，构造密文 $c'=c\cdot (x^e)$ 使解密后明文为 $m'=(m\cdot x)\mod n$，则 $m=m'\cdot x^{-1} \mod n$。可参看模意义下的运算法则部分

>如何利用该方式在 $gcd(e,phi)!=1,d$ 不存在时还原明文

## 最低bit位泄露(lsb oracle)

每次返还的结果为明文是奇数还是偶数，可以构造得到 $(2\cdot m) \mod n$ ，因为 $2\cdot m$ 是偶数而 $n$ 为奇数，且 $m < n$ ，所以当 $(2\cdot m) \mod n$ 最低位变为奇数时，有 $2\cdot m > n$ 。

以此类推，将 $2\cdot m$ 视为新的开始，重复上述操作，即可不断逼近m

## 至少已知明文m的ceil(nBitSize*(1-1.0/e))位

LLL attack

## 已知密钥d低位d0位数大于nBitSize/4

Partial Key Exposure Attack

## 已知密钥d低位d0位数大于nBitSize/2

Partial Key Recovery Attack

## 已知dp、dq

```python
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

# dp = d mod p-1
# dq = d mod q-1

import libnum

res = libnum.solve_crt([pow(c, dp, p), pow(c, dq, q)], [p, q])
res = libnum.n2s(res)
print(res)
```

# 广播攻击

## 同e同m低加密指数指数广播攻击

如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。

即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：

$c_1\equiv m^e\mod n_1$

$c_2\equiv m^e\mod n_2$

$c_3\equiv m^e\mod n_3$

对上述等式运用中国剩余定理，在e=3时，可以得到：

$c_x\equiv m^3\mod n_1n_2n_3$

由于 $m< min(n_1, n_2, n_3)$ 此时 $m^3$ 一定没有被模数删去一部分，可以直接求根

通过对 $c_x$ 进行三次开方可以求得明文。

## 同e不同n明文有线性关系的广播攻击

Hastad’s Broadcast Attack with Linear Padding

## 同e同n铭文有线性关系的广播攻击

$M_1=a*M_2+b$

$M_2=\frac{2a^3bC^2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\frac{b}{a}\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3}$

```python
def relate_message_attack(a, b, c1, c2, n):
b3 = gmpy2.powmod(b, 3, n)
part1 = b * (c1 + 2 * c2 - b3) % n
part2 = a * (c1 - c2 + 2 * b3) % n
part2 = gmpy2.invert(part2, n)
return part1 * part2 % n
```

# 共模攻击

## 同m同n共模攻击

如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。

$c_1\equiv m^{e_1}\mod n$

$c_2\equiv m^{e_2}\mod n$

此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。

过程如下，首先两个加密指数互质，则：

$(e_1,e_2)=1$

即存在 $s_1$， $s_2$ 使得：

$s_1e_1+s_2e_2=1$

又因为：

$c_1\equiv m^{e_1}\mod n$

$c_2\equiv m^{e_2}\mod n$

通过代入化简可以得出：

$c_1^{s_1}c_2^{s_2}\equiv m\mod n$

# 爆破攻击

## 低加密指数爆破

当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。

即：

$c\equiv m^e\mod n$

如果 $e=3$，且 $m^e< n$，那么：

$c = m^e, e = 3$

$m = sqrt[3]{c}$

如果明文的三次方比n大，但是不是足够大，那么设k，有：

$c = m^e+kn$

爆破 $k$，如果 $c-kn$ 能开三次根式，那么可以直接得到明文。

```python
n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793
e = 0x3
c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365

import libnum

for i in range(0, 0x10000):
    if pow(libnum.nroot(c+i*n, 3), 3, n) == c:
        m = libnum.nroot(c+i*n, 3)
        print(libnum.n2s(m))
        break
```

其他工具如wolframalpha、Pari/GP