---
title: 应用程序二进制接口
date: 2022-08-17 18:10:00 +0800
categories: [Linux, Basic]
tags: [linux, basic, abi]     # TAG names should always be lowercase
---

# 内存对齐
内存对齐”应该是编译器的“管辖范围”。编译器为程序中的每个“数据单元”安排在适当的位置上。以便CPU一个步长(一字节)快速搜索。
一般体现在结构体和类上。
1. 对齐原因
- 平台原因(移植原因): 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- 性能原因: 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
2. 对齐系数
- 每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。
3. 对齐规则
按照成员的声明顺序，依次安排内存，如果紧接着插入的成员使得当前步长爆满，则在下一个步长起始地址放入该成员。使得CPU不会进行两个步长来读取数据。

# 常见指令

- mov
- lea 加载有效地址
- call = push retaddr + jmp
- leave = mov rsp,rbp + pop rbp
- ret = pop rip

## 算术与逻辑指令
## 控制转移指令

# intel语法与AT&T语法差异

- 操作数顺序
- 寄存器记法
- 立即数记法
- 访存寻址记法
- 操作码助记符

Intel|AT&T
--|--
mov eax,8|movl $8,%eax
mov ebx,0ffffh|movl $0xffff,%ebx
int 80h|int $80
mov eax,[ecx]|movl (%ecx),%eax

# 函数

## 函数序言(Function Prologue)

push ebp
mov ebp,esp
sub esp,X

## 函数尾声(Function Epilogue)

mov eax,X
mov esp,ebp
pop ebp
ret

## 调用方式

Language|C|SysCall|StdCall|BASIC|FORTRAN|PASCAL
--|--|--|--|--|--|--
参数入栈顺序|右→左|右→左|右→左|左→右|左→右|左→右|左→右
恢复栈平衡操作的位置|母函数|子函数|子函数|子函数|子函数|子函数

## 调用约定

- 实现了层面（底层）的规范
- 约定了函数之间如何传递参数
- 约定了函数如何传递返回值
- 修饰名
- 调用者负责清理栈上的参数(Caller Clean-up)
  - cdecl
  - optlink
- 被调用者负责清理栈上的参数(Callee Clean-up)
  - stdcall
  - fastcall

调用约定的声明|参数入栈顺序|恢复栈平衡的位置
--|--|--
_cdecl|右→左|母函数
_fastcall|右→左|子函数
_stdcall|右→左|子函数

## cdecl amd64

- 使用寄存器%rdi、%rsi、%rdx、%rcx、%r8、%r9来传递前6个参数
- 其余参数通过栈传递

## cdecl x86

- 用栈来传递参数
- 用寄存器%eax来保存返回值

![avatar](pic/basic/cdeclx86.png)