---
title: x86保护模式与内存管理
date: 2022-10-20 11:15:00 +0800
categories: [Linux, Basic]
tags: [x86, memory, privilege, interrupt]     # TAG names should always be lowercase
---

# 特权级

intel CPU 一般有实模式、保护模式和长模式三种工作模式。其中保护模式的段选择子和段描述符使用特权级描述代码特权。

x86 处理器将特权级分为4个级别，用两个比特位表示，其中0为最高特权级。

基于以下原因大多数操作系统只使用0和3两个特权级

1. 实用性：分页管理不需要细致的特权级。
2. 可移植性：常规操作系统需要兼容其他架构，而大多数架构只实现了2个特权级。
3. 效率：切换特权级本身就是有开销的，但是与之相应的收益却不大。大多数情况下 ring2 和 ring3 的安全情况一致，而ring1经常调用 ring0 不如直接放入 ring0。

通常将特权分为DPL、CPL、RPL和IOPL四种，用来表示不同情景下的特权级。这里先作介绍，后面会结合场景使用。

## 描述符特权级(Descriptor Privilege Level)

DPL 表示段或门的特权级。存储在**段描述符**或者门描述符的 DPL 字段中。

## 当前特权级(Current Privilege Level)

CPL 是当前执行的程序或任务的特权级。存储在 **CS** 等段寄存器的第0位和第1位上。

调整段寄存器段索引的同时会将描述符写入描述符高速缓存中。以 CS 段寄存器为例，通过 CS 对应描述符指向的基地址和 EIP 存储的偏移值计算指令地址。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8.drawio.svg){: .shadow}
_段寄存器_

## 请求特权级(Request Privilege Level)

RPL 是通过**段选择子**的第0和第1位表现出来的。当 RPL > DPL 的时候，RPL 才起到实际的限制作用。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.drawio.svg){: .shadow}
_段选择子_

## IO特权级(I/O Privilege Level)

IOPL 是当前任务的I/O特权级别，存储在EFLAGS的第13位和第12位上。

正在运行任务的 CPL 必须小于或等于 I/O 特权级才能允许访问 I/O 地址空间。这个域只能在 CPL 为0时才能通过 POPF 以及 IRET 指令修改。

## 特权级检查

1. 将控制直接转移到非一致性的代码段：jmp 0x0012:0x00002000，jmp转移后当前特权级不变。
    
    CPL==目标代码段描述符的 DPL

    RPL==目标代码段描述符的 DPL
2. 将控制直接转移到非一致性的代码段：call，call转移后改变特权级(CPL = DPL)，只有call指令可以将代码通过调用门转移到特权级更高的非一致性代码之中。
3. 将控制直接转移到一致性的代码段，特权级不变。

    CPL≥目标代码段描述符的 DPL

    RPL≥目标代码段描述符的 DPL
4. 高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。访问数据段之前，肯定要对段寄存器 DS、ES、FS 和 GS 进行修改。例 mov fs,ax 在这个时候，要求当前特权级 CPL 和请求特权级 RPL 都必须高于，或者和目标数据段描述符的 DPL 相同。

    CPL≤目标数据段描述符的 DPL

    RPL≤目标数据段描述符的 DPL
5. 处理器要求，在任何时候，栈段的特权级别必须和当前特权级 CPL 相同。因此，要对段寄存器 ss 的内容进行修改时，必须进行特权级检查。例 mov ss,ax 在对段寄存器ss进行修改时，要求当前特权级 CPL 和请求特权级 RPL 必须等于目标栈段描述符的 DPL。

    CPL==目标栈段描述符的 DPL

    RPL==目标栈段描述符的 DPL


# 描述符

描述符通常使用在中断描述符表、全局描述符表和局部描述符表中作为基本单元，这里介绍描述符的基本结构。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.drawio.svg){: .shadow}
_描述符结构_

上述描述符结构主要适用于段描述符、TSS 描述符和 LDT 描述符，常使用在GDT和LDT中，详细参数解释如下

符号|含义
--|--
G(Granularity)|段界限的单位量，G 为0时单位量为字节，G 为1时单位量为4K。
S(System)|S 为1时是数据段或数据段，S 为0时是系统段，在 CPU 的世界里，系统段主要是指各种称为门的结构，如调用门和任务门；数据段主要是指操作系统及应用程序的代码、数据以及栈。
TYPE|TYPE 用来表示段描述符的类型。
DPL|表示描述符特权级，特权级的数字越小，特权级越大。CPU 进入保护模式（操作系统的代码）默认为0。
P(Present)|用来标识段是否存在内存中，1表示存在。如果为0，CPU 将抛出异常，跳转到我们编写的异常处理程序，在处理完成以后，需要将该字段置为1。
AVL|对于操作系统来说，此位没有效果
L(Long Mode)|L 为1表示64位代码段，否则表示32位代码段
D/B|用来指示有效地址（段内偏移地址）及操作数的大小。如果段是代码段，0表示指令中的有效地址地址和操作数是16位，指令地址使用 IP 寄存器，1代表指令中的有效地址和操作数是32位，指令有效地址用 EIP 寄存器；对于栈段来说，0使用的是 SP 寄存器，1使用的是 ESP 寄存器

## 系统段类型

系统段类型|11|10|9|8
--|--|--|--|--
LDT|0|0|1|0
TSS|1|0|0|1
忙碌的 TSS|1|0|1|1
可用的80286 TSS|0|0|0|1
忙碌的80286 TSS|0|0|1|1
任务门|0|1|0|1
调用门|1|1|0|0
中断门|1|1|1|0
陷阱门|1|1|1|1
80286调用门|0|1|0|0
80286中断门|0|1|1|0
80286陷阱门|0|1|1|1

## 非系统段类型

非系统段可以分为代码段和数据段

X|R|C|A|代码段描述
1|0|0|*|可执行
1|1|0|*|可执行+可读
1|0|1|*|可执行+一致性
1|1|1|*|可执行+可读+一致性

X|W|E|A|数据段描述
0|0|0|*|只读
0|1|0|*|可读+可写
0|0|1|*|只读+向下扩展
0|1|1|*|可读+可写+向下扩展

一致性代码可以被低特权级用户直接调用，后面会详细说明。

创建段时 A 位默认为0，当操作系统访问过后置1。

E 位表示扩展方向，0向上，1向下，常见的栈段为向下。

## 段描述符

段描述符为最基本的描述符结构，存在于 GDT 和 LDT 中

## TSS描述符

TSS 描述符采用了描述符基本结构。

TSS 描述符仅可能存放在 GDT 中，不能存放在 LDT 或 IDT 中。

x86 的构想是每一个任务对应一个 TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。包括 Linux 和 Windows 在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换，但有时一些异常处理会使用到 TSS 来执行处理。

TR 寄存器分为可见和不可见两部分，可见部分中的段选择符指向 GDT 中 TSS 描述符，不可见部分缓存TSS的描述符。当把任务状态段的选择子装入到 TR 可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。

更新 TR 顺序：GDT选择子==>访问GDT==>TSS描述符(根据TR段索引确定)==>访问TSS(==>加载到TR)；

TSS 描述符所指向的 TSS 结构如下所示

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TSS%E7%BB%93%E6%9E%84.drawio.svg){: .shadow}
_TSS结构_

TR 寄存器结构如下

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TR.drawio.svg){: .shadow}
_TR_

## LDT描述符

局部描述符表寄存器 LDTR 规定当前任务使用的局部描述符表 LDT。

LDT 描述符仅存在于 GDT 中

更新 LDTR 顺序：GDT选择子==>访问GDT==>LDT描述符(根据LDTR段索引确定)==>访问LDT(==>加载到LDTR)；

LDTR 寄存器结构如下

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/LDTR.drawio.svg){: .shadow}
_LDTR_

# 门描述符

在上一节描述符中我们介绍了通用的描述符结构，但是对具体TYPE类型中的各门，该结构不再适用，这一节将分别介绍各门的描述符结构。

门描述符通常为中断描述符表常用的基本单元，但需要注意**有些门并不能使用在IDT中，而有些门不仅能使用在IDT中**。

## 任务门描述符(Task Gate)

任务门需要和任务状态段(TSS)配合使用，这是Intel处理器在硬件一级提供的任务切换机制。

任务门可以存在于GDT、LDT和IDT中。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.drawio.svg){: .shadow}
_任务门描述符_

## 调用门描述符(Call Gate)

调用门是用户进程用来进入0特权级的方式，其DPL为3，只能使用call和jmp指令调用。

调用门可以存在于GDT和LDT中，不能存在于IDT

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%B0%83%E7%94%A8%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.drawio.svg){: .shadow}
_调用门描述符_

## 中断门描述符(Interrupt Gate)

中断门包含中断处理程序所在的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，表示把中断关闭，避免中断嵌套。

中断们只存在于IDT中。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.drawio.svg){: .shadow}
_中断门描述符_

## 陷阱门描述符(Trap Gate)

通过陷阱门进入中断，标志寄存器eflags的IF位不会自动置0。

陷阱门只存在于IDT中。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%99%B7%E9%98%B1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.drawio.svg){: .shadow}
_陷阱门描述符_


# 描述符表

## 中断描述符表(Interrupt Description Table)

IDTR表示中断描述符表寄存器，用来寻找中断描述符表的位置。

当发生中断时，通过中断向量索引中断描述符表，以8字节为步长。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.drawio.svg){: .shadow}
_中断描述符表_


## 全局描述符表(Global Description Table)

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/GDTR.drawio.svg){: .shadow}
_GDTR_

通过 GDTR 可以确定 GDT 的位置，通过 LDTR 可以确定 LDT 的位置，通过 IDTR 可以确定 IDT 的位置。综合前面所述，我们可以大致了解三个表的布局情况。

通过中断向量搜索 IDT 表进而得到相应的门描述符进一步在 GDT 和 LDT 中搜索得到具体地址。

通过选择子可以直接在 LDT 或 GDT 中搜索。

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.drawio.svg){: .shadow}
_保护模式结构_

# 中断系统

中断本身的分类是复杂的，这里主要介绍x86的四大类中断

类别|原因|返回
中断|I/O设备|下一条指令
陷阱|异常，例如调试陷阱、单步中断指令 int3 和溢出检测指令 into。陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。|下一条指令
故障|潜在可恢复错误，例如缺页故障|当前指令
终止|不可恢复错误，例如双重故障异常、协处理器段越界|不返回

## 门处理中断

有些异常必须由中断门或陷阱门进行处理，如设备不可用故障(异常7)，该故障在下列情况下产生：(1)在执行浮点指令时，控制寄存器 CR0 中的 EM 位或 TS 位为1；(2)在执行 WAIT 指令时，控制寄存 器CR0 中 TS 位及 EM 位都为1。

无效 TSS 异常必须使用任务门进行处理，以保证处理程序有一个有效得任务环境。其它的异常通常在任务环境之内进行处理。

通过中断门访问的中断处理程序，必须置于全局地址空间中，以便对所有的任务都有效。在使用中断门时，中断处理程序通常必须被安排在特权级0。


# 分页机制

x86 分页机制通过 CR0 和 CR3 实现，为其初始化 PE+PG+页目录基址即可。

## 控制寄存器组

![img](/assets/img/2022-10/2022-10-20-x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84.drawio.svg){: .shadow}
_控制寄存器组_

我们主要关注CR0、CR2和CR3，并忽略一些不重要的位。

### CR0 

- PE：CR0 的第0位是启用保护(Protection Enable)标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。
- PG：CR0 的第31位是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么 PE 和 PG 标志都要置位。

### CR2

是页故障线性地址寄存器，保存最后一次出现页故障(Page Fault)的全32位线性地址。在报告页异常时，处理器会把引起异常的线性地址存放在 CR2 中。因此操作系统中的页异常处理程序可以通过检查 CR2 的内容来确定线性地址空间中哪一个页面引发了异常。

### CR3

- PCD：控制当前页目录表的缓冲，当设置清空时，缓冲置位时，缓冲无效，与 CR0 中的 CD 或 PG 一同使用
- PWT：控制 cache 采取直写还是回写的策略，当设置清空时，回写有效，当置位时，直写有效

## 现代操作系统分页机制

前面介绍了很多段描述符相关的知识，但是现代操作系统主要是基于分页的，这种分段机制很鸡肋。所以通常操作系会直接将段设置为基地址为0，限长最大的情况。也就是说将代码段、数据段和栈段等直接整合在4GB的内存空间中，此时段机制基本也就没用了。一般称这种行为为平坦模式。


# 参考

1. [全局描述符表](https://zhuanlan.zhihu.com/p/389448141)
2. [中断描述符表](https://zhuanlan.zhihu.com/p/400007642)
3. [x86 - 特权级别 CPL / RPL / DPL / IOPL](https://blog.csdn.net/Gyc8787/article/details/121879012)
4. [x86 - CPU架构/寄存器详解 （三） 保护模式](https://blog.csdn.net/Gyc8787/article/details/121779971)
5. [任务状态段TSS及TSS描述符、局部描述符表LDT及LDT描述符](https://blog.csdn.net/MJ_Lee/article/details/104419980/)
6. [操作系统篇-分段机制与GDT LDT](https://www.cnblogs.com/chenwb89/p/operating_system_003.html)
7. [x86 - 操作系统：中断、陷阱、异常、故障、终止](https://blog.csdn.net/Gyc8787/article/details/121879298)
8. [操作系统篇-调用门与特权级（CPL、DPL和RPL）](https://www.cnblogs.com/chenwb89/p/operating_system_004.html)
9. [现代操作系统管理内存，到底是分段还是分页，段寄存器还有用吗？](http://t.zoukankan.com/xuanyuan-p-15266447.html)
10. IA-32 架构软件开发人员手册
