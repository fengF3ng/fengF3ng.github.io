<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="ptmalloc总结" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="memory allocators" /><meta property="og:description" content="memory allocators" /><link rel="canonical" href="https://fengf3ng.github.io/posts/ptmalloc%E6%80%BB%E7%BB%93/" /><meta property="og:url" content="https://fengf3ng.github.io/posts/ptmalloc%E6%80%BB%E7%BB%93/" /><meta property="og:site_name" content="fengF3ng’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-10T22:10:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ptmalloc总结" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-10T22:10:00+08:00","datePublished":"2022-09-10T22:10:00+08:00","description":"memory allocators","headline":"ptmalloc总结","mainEntityOfPage":{"@type":"WebPage","@id":"https://fengf3ng.github.io/posts/ptmalloc%E6%80%BB%E7%BB%93/"},"url":"https://fengf3ng.github.io/posts/ptmalloc%E6%80%BB%E7%BB%93/"}</script><title>ptmalloc总结 | fengF3ng's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="fengF3ng's Blog"><meta name="application-name" content="fengF3ng's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/sidebar/nanachi.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">fengF3ng's Blog</a></div><div class="site-subtitle font-italic">专注个人笔记</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/fengF3ng" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hefeng.hf','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>ptmalloc总结</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>ptmalloc总结</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1662819000" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-09-10 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/fengF3ng">fengF3ng</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3764 字"> <em>20 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="memory-allocators">memory allocators</h1><ul><li>dlmalloc：通用分配器，是旧linux的默认分配器<li>ptmalloc2-glibc：基于dlmalloc fork<li>jemalloc-FreeBSD、Firefox、Android<li>tcmalloc-Google Chrome<li>libumem-Solaris<li>Windows10-segment heap</ul><h1 id="main-arena">main arena</h1><p>指的是堆内存区域本身，并非结构。</p><p>通过sbrk创建，主分配区可以使用brk和mmap来扩张</p><p>主分配区和非主分配区形成一个环形链表进行管理。通过malloc_state-&gt;next来链接。</p><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/main_arena.png" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Main Arena</em></p><h2 id="内存申请方式"><span class="mr-2">内存申请方式</span><a href="#内存申请方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1，由操作系统提供。<li>sbrk用来增加heap，增加的大小通过参数increment决定，以页大小为单位，返回增加大小前的heap的program break，如果increment为0则返回program break，由glibc提供。<li>mmap：第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。<li>munmap：用于释放内存。</ul><p><code class="language-plaintext highlighter-rouge">int brk(void *addr);</code></p><p><code class="language-plaintext highlighter-rouge">void *sbrk(intptr_t increment);</code></p><p><code class="language-plaintext highlighter-rouge">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p><code class="language-plaintext highlighter-rouge">int munmap(void *addr, size_t length);</code></p><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/heap_extend.drawio.svg" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Heap申请内存</em></p><h1 id="thread-arena">thread arena</h1><ul><li>不同线程维护不同的堆称为per thread arena<li>只能使用mmap来映射内存<li>数量一旦增加，则不会减少<li>起始地址总是HEAP_MAX_SIZE对齐的.<li>每个thread arena中最初包含一个heap，当其内存用完后，会继续分配新的heap并加入到thread arena中。<li>arena的数量受到CPU核数的限制<ul><li>32位系统：arena数量上限=2*核数<li>64位系统：arena数量上限=8*核数</ul></ul><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/thread_arena.png" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Thread Arena</em></p><h1 id="heap_info">heap_info</h1><p>每个堆的头部，main arena由于只有一个heap所以没有heap_info。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">//arena.c</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_heap_info</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span> <span class="cm">/* Arena for this heap. */</span>
  <span class="k">struct</span> <span class="n">_heap_info</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="cm">/* Previous heap. */</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/* Current size in bytes. */</span>
  <span class="kt">size_t</span> <span class="n">mprotect_size</span><span class="p">;</span> <span class="cm">/* Size in bytes that has been mprotected
                           PROT_READ|PROT_WRITE.  */</span>
  <span class="cm">/* Make sure the following data is properly aligned, particularly
     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
     MALLOC_ALIGNMENT. */</span>
  <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_info</span><span class="p">;</span>
</pre></table></code></div></div><h1 id="malloc_state">malloc_state</h1><p>管理arena的核心结构，包含堆的状态信息、bins链表等，每个arena可以有多个heap，但只能有一个malloc_state。</p><p>main_arena的malloc_state是一个全局变量，位于libc.so的data segment，其他线程arena对应的malloc_state存储在arena本身当中。</p><p>main_arena的偏移存放在libc中的malloc_trim()函数中。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">//malloc.c</span>
<span class="k">struct</span> <span class="n">malloc_state</span>
<span class="p">{</span>
  <span class="cm">/* Serialize access.  */</span>
  <span class="n">__libc_lock_define</span> <span class="p">(,</span> <span class="n">mutex</span><span class="p">);</span> <span class="c1">// 线程锁</span>
  <span class="cm">/* Flags (formerly in max_fast).  */</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/* Fastbins */</span>
  <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>
  <span class="cm">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
  <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>
  <span class="cm">/* The remainder from the most recent split of a small request */</span>
  <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>
  <span class="cm">/* Normal bins packed as described above */</span>
  <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
  <span class="cm">/* Bitmap of bins */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binmap</span><span class="p">[</span><span class="n">BINMAPSIZE</span><span class="p">];</span> <span class="c1">// ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</span>
  <span class="cm">/* Linked list */</span>
  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 分配区全局链表，主分配区放头部，新加入的分配区放main_arean.next 位置</span>
  <span class="cm">/* Linked list for free arenas.  Access to this field is serialized
     by free_list_lock in arena.c.  */</span>
  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span> <span class="c1">// 空闲的分配区</span>
  <span class="cm">/* Number of threads attached to this arena.  0 if the arena is on
     the free list.  Access to this field is serialized by
     free_list_lock in arena.c.  */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">attached_threads</span><span class="p">;</span>
  <span class="cm">/* Memory allocated from the system in this arena.  */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="malloc_chunk">malloc_chunk</h1><ul><li>prev_size：前一个块free，记录前一个块大小；未被free，可以被前一个chunk的用户数据空间复用<li>size：每次对齐的时候，都需要加上prev_size和size两个字段的空间值2*SIZE_SZ，第三位AMP<li>NON_MAIN_ARENA：A=0为主分区分配，A=1 为非主分区分配<li>IS_MAPPED：M=1表示使用mmap映射区域<li>PREV_INUSE：P=1表示pre_chunk空闲<li>fd和bk：在bins中时，占用用户数据空间链接其他free chunk<li>fd_nextsize和bk_nextsize：用于管理large块的时候的空闲chunk双向链表的管理。<li>chunk按照2*SIZE_SZ进行对齐，32位系统是8字节，64位系统是16字节。<li>最小的空间：prev_size字段+size字段+fd字段+bk字段=4*SIZE_SZ</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">//malloc.c</span>
<span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span> <span class="cm">/* 前一个空闲chunk的大小*/</span>
    <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>      <span class="cm">/* 字节表示的chunk大小，包括chunk头 */</span>
    <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* 双向链表 -- 只有在被free后才存在 */</span>
    <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>        <span class="cm">/* fd：前一个空闲的块  bk：后一个空闲的块*/</span>
    <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span>  <span class="cm">/*块大小超过512字节后会有这两个指针*/</span>
    <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//prev_size ：前一块被free的话则为空闲块的大小，前一块未被free的话则为0</span>
<span class="c1">//size ： 因为chunk是四字节对齐所以size的低三位一定是0，被用来做flag</span>
</pre></table></code></div></div><h1 id="chunk">chunk</h1><h2 id="free-chunk"><span class="mr-2">free chunk</span><a href="#free-chunk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/free_chunk.drawio.svg" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Free Chunk</em></p><h2 id="allocated-chunk"><span class="mr-2">allocated chunk</span><a href="#allocated-chunk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>chunk的P flag决定了prev_size字段是否有意义<li>allocated chunk可以使用下一个chunk的prev_size字段</ul><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/allocated_chunk.drawio.svg" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Allocated Chunk</em></p><h2 id="top-chunk"><span class="mr-2">top chunk</span><a href="#top-chunk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>不属于任何bin，在arena中处于最高地址<li>当没有其他空闲块时，top chunk就会被用于分配<li>分裂时<ul><li>一块时请求大小的chunk<li>另一块余下chunk将成为新的top chunk</ul><li>main arena通过sbrk拓展top chunk，thread arena通过mmap系统调用拓展top chunk</ul><h2 id="last_remainder-chunk"><span class="mr-2">last_remainder chunk</span><a href="#last_remainder-chunk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>当请求small chunk大小的内存时，无法通过small bin何unsorted bin提供时，binmaps遍历寻找下一个最大非空bin。将该bin分裂成两部分，一部分返回给用户，剩余部分添加到unsorted bin。除此之外，添加到unsorted bin的chunk成为新的last_remainder chunk<li>生成last_remainder chunk后malloc_state结构体中的last_remainder成员指针就会被初始化，并且指向这个chunk</ul><h2 id="mmaped-chunk"><span class="mr-2">mmaped chunk</span><a href="#mmaped-chunk" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。</ul><h1 id="bins">bins</h1><p>bins是用来管理和组织空闲内存块的链表结构，根据chunk的大小和状态，有许多不同的bins结构</p><h2 id="fast-bins"><span class="mr-2">fast bins</span><a href="#fast-bins" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>10个bin<li>8B apart<li>LIFO<li>16-64B(32bit)、32-128B(64bit)<li>single linked list<li>No Coalescing:Two chunks which are free can be adjacent to each other, it doesnt get combined into single free chunk.<li>free时不会清理PREV_INUSE<li>对应malloc_state数据结构fastbinsY</ul><h3 id="fastbins-index-check"><span class="mr-2">fastbins index check</span><a href="#fastbins-index-check" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>可以看出不做对齐检查，伪造的chunk的size可以不完全合法<li>例如0x7f可以成为0x70bin的合法size(64bit)</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#define fastbin_index(sz) \
  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
</span><span class="p">...</span>
<span class="p">...</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></table></code></div></div><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/fast_bin_snapshot.png" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Fastbin</em></p><h2 id="unsorted-bin"><span class="mr-2">unsorted bin</span><a href="#unsorted-bin" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>When small or large chunk gets freed instead of adding them in to their respective bins, its gets added into unsorted bin.<li>unsorted_bin中free_chunk的fd和bk指向了main_arena+88<li>bins 0-1<li>double-linked circular list<li>unsorted bin中的chunkNON_MAIN_ARENA总是为0。</ul><h2 id="small-bins"><span class="mr-2">small bins</span><a href="#small-bins" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>less than 512B(32bit)、1024B(64bit)<li>bins 2-125共62组<li>起始0x10B(32bit)、0x20B(64bit)<li>FIFO<li>8B(32bit)、16B(64bit) apart<li>double-linked circular list</ul><h2 id="large-bins"><span class="mr-2">large bins</span><a href="#large-bins" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>greater than equal to 512B(32bit)、1024B(64bit)<li>bins 126-253共64组<li>FIFO<li>同一个bin内大小不一定相同，大块放在队首，小块放在队尾<li>out of these 64 bins:<ul><li>32 bins 64B<li>16 bins 512B<li>8 bins 4096B<li>4 bins 32768B<li>2 bins 262144B<li>1 bin contains a chunk of remaining size</ul><li>double-linked circular list<li>对于large chunk而言，在malloc_chunk中除了fd和bk指针，还包含了fd_nextsize和bk_nextsize指针，指向不同大小的chunk</ul><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/bin_snapshot.png" alt="Window shadow" class="shadow" data-proofer-ignore> <em>Bin</em></p><ul><li>第一个插入bin内的堆fd、bk与bin进行连接，fd_nextsize、bk_nextsize指向自身<li>不同大小的chunk，堆中fd_nextsize指向比它小的堆块的堆头，bk_nextsize指向比它大的堆块的堆头<li>同样大小的chunk，先释放的成为堆头，FIFO，通过fd、bk在相同大小chunk间连接，fd_nextsize、bk_nextsize为0</ul><h2 id="tcacheper-thread-cache"><span class="mr-2">tcache(per-thread cache)</span><a href="#tcacheper-thread-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>glibc2.26引入<li>每个tcache bin最多只能有7个(TCACHE_FILL_COUNT)chunk<li>tcache bin中chunk的inuse位不会置零，也就是说不会进行合并<li>LIFO<li>每个线程都会维护一个tcache_prethread_struct，它是整个tcache机制的管理结构，链入其中的chunk大小相同<li>tcache_entry用于链接空闲的chunk，指针直接指向chunk的userdata部分，也就是说复用了指针的含义。<li>释放时在填满tcache之后才进入传统的释放过程，分配时也先从tcache中搜索。</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp"># define TCACHE_FILL_COUNT 7
</span><span class="p">...</span>
<span class="p">...</span>
<span class="cp"># define TCACHE_MAX_BINS		64
</span><span class="p">...</span>
<span class="p">...</span>
<span class="cm">/* We overlay this structure on the user-data portion of a chunk when
   the chunk is stored in the per-thread cache.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>

<span class="cm">/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_perthread_struct</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">counts</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tcache_perthread_struct</span><span class="p">;</span>

<span class="cp">#define MAX_TCACHE_COUNT 127	</span><span class="cm">/* Maximum value of counts[] entries.  */</span><span class="cp">
</span></pre></table></code></div></div><h1 id="malloc">malloc</h1><p><code class="language-plaintext highlighter-rouge">static void* _int_malloc(mstate, size_t);</code></p><ol><li>如果size <code class="language-plaintext highlighter-rouge">&lt;</code> max_fast，在fast bins中寻找fast chunk，如找到则结束<li>如果size in_smallbin_range，在small bins中寻找small chunk，如找到则结束<li>循环<ol><li>检查unsorted bin中的last_remainder，如果满足一定条件，则分裂之，将剩余chunk标记为新的last_remainder<li>在unsorted bin中搜索，同时进行整理，如遇到精确大小，则返回，否则就把当前chunk整理到small/large bin中去<li>在small bin和large bin中搜索最合适的chunk</ol><li>使用top chunk</ol><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/malloc.png" alt="Window shadow" class="shadow" data-proofer-ignore><em>malloc</em></p><h1 id="free">free</h1><p><code class="language-plaintext highlighter-rouge">static void _int_free(mstate, mchunkptr, int);</code></p><ol><li>如果size <code class="language-plaintext highlighter-rouge">&lt;</code> max fast，放入fast bin，结束<li>如果前一个chunk是free<ol><li>unlink前面的hunk<li>合并两个chunk，并放入unsorted bin</ol><li>如果后一个chunk是top chunk，则将当前chunk并入top chunk<li>如果后一个chunk是free<ol><li>unlink后面的chunk<li>合并两个chunk，并放入unsorted bin</ol><li>前后chunk都不是free，放入unsorted bin</ol><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/free.png" alt="Window shadow" class="shadow" data-proofer-ignore><em>free</em></p><h1 id="调用流程">调用流程</h1><h2 id="__libc_malloc"><span class="mr-2">__libc_malloc</span><a href="#__libc_malloc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>glibc通过别名机制将malloc映射到__libc_malloc</p><p><code class="language-plaintext highlighter-rouge">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)</code></p><p><img data-src="/assets/img/2022-09/2022-09-10-ptmalloc%E6%80%BB%E7%BB%93/libc_malloc.png" alt="Window shadow" class="shadow" data-proofer-ignore><em>libc malloc流程</em></p><ul><li>mstate ar_ptr指向全局内存分配器的指针，说白了就是全局内存分配器状态机。<li>atomic_forced_read 是汇编语句，用于原子读操作，每次只会读取一次。例如调用malloc_hook_ini初始化只会调用一次</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">//malloc.c</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">__libc_malloc</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

  <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_hook</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  <span class="n">arena_get</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

  <span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
  <span class="cm">/* Retry with another arena only if we were able to find a usable arena
     before.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">&amp;&amp;</span> <span class="n">ar_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_malloc_retry</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_get_retry</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">__libc_lock_unlock</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

  <span class="n">assert</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">||</span> <span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">||</span>
          <span class="n">ar_ptr</span> <span class="o">==</span> <span class="n">arena_for_chunk</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">)));</span>
  <span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">__libc_malloc</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="hook"><span class="mr-2">hook</span><a href="#hook" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//malloc.c</span>
<span class="kt">void</span> <span class="n">weak_variable</span> <span class="p">(</span><span class="o">*</span><span class="n">__free_hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__ptr</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">weak_variable</span> <span class="p">(</span><span class="o">*</span><span class="n">__malloc_hook</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">size_t</span> <span class="n">__size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">malloc_hook_ini</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">weak_variable</span> <span class="p">(</span><span class="o">*</span><span class="n">__realloc_hook</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">realloc_hook_ini</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">weak_variable</span> <span class="p">(</span><span class="o">*</span><span class="n">__memalign_hook</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">size_t</span> <span class="n">__alignment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">__size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">memalign_hook_ini</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">weak_variable</span> <span class="p">(</span><span class="o">*</span><span class="n">__after_morecore_hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>第一个同malloc的size参数，第二个参数是调用malloc的那个函数的地址<li>__malloc_hook相当于给malloc函数套了一层外壳，当这个函数指针的值不为NULL时，系统在调用malloc是就会触发这个hook，执行hook所指向的函数</ul><h2 id="malloc_hook_ini"><span class="mr-2">malloc_hook_ini</span><a href="#malloc_hook_ini" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>主要用于初始化全局状态机+chunk的数据结构</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">//hook.c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">malloc_hook_ini</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__malloc_hook</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">ptmalloc_init</span> <span class="p">();</span>
  <span class="k">return</span> <span class="n">__libc_malloc</span> <span class="p">(</span><span class="n">sz</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="ptmalloc_init"><span class="mr-2">ptmalloc_init</span><a href="#ptmalloc_init" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>初始化全局内存分配器的状态机<li>通过__malloc_initialized全局变量，来记录初始化的状态。0=未初始化，1-初始化。如果已经初始化，则直接返回<li>main_arena是全局内存分配器状态机的主线程结构，数据结构：mstate<li>malloc_init_state是核心初始化mstate状态机数据结构</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">ptmalloc_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__malloc_initialized</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">__malloc_initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef SHARED
</span>  <span class="cm">/* In case this libc copy is in a non-default namespace, never use brk.
     Likewise if dlopened from statically linked program.  */</span>
  <span class="n">Dl_info</span> <span class="n">di</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_dl_open_hook</span> <span class="o">!=</span> <span class="nb">NULL</span>
      <span class="o">||</span> <span class="p">(</span><span class="n">_dl_addr</span> <span class="p">(</span><span class="n">ptmalloc_init</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
          <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_ns</span> <span class="o">!=</span> <span class="n">LM_ID_BASE</span><span class="p">))</span>
    <span class="n">__morecore</span> <span class="o">=</span> <span class="n">__failing_morecore</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="n">thread_arena</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">;</span>

<span class="c1">// 初始化主分配区数据</span>
<span class="cp">#if HAVE_TUNABLES
</span><span class="p">...</span>
<span class="p">...</span>
<span class="n">malloc_consolidate</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">main_arena</span><span class="p">);</span>
<span class="cp">#else
</span><span class="p">...</span>
<span class="p">...</span>
<span class="cp">#endif
</span>
<span class="cp">#if HAVE_MALLOC_INIT_HOOK
</span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_initialize_hook</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>
<span class="cp">#endif
</span>  <span class="n">__malloc_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="malloc_init_state"><span class="mr-2">malloc_init_state</span><a href="#malloc_init_state" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>malloc_init_state是核心初始化mstate状态机数据结构<li>初始化中由malloc_consolidate调用<li>fastbin中支持的fastchunk的默认最大值为128字节。在glibc中用“DEFAULT_MXFAST”宏定义表示<li>支持的fastchunk的数据空间最大为160字节。在glibc中用“MAX_FAST_SIZE”宏定义表示<li>初始化top chunk，默认指向了unsorted bin上的第一个chunk<li>将bins进行初始化，生成bins数组</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#ifndef DEFAULT_MXFAST
#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)
#endif
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)
</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">malloc_init_state</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">mbinptr</span> <span class="n">bin</span><span class="p">;</span>

  <span class="cm">/* Establish circular links for normal bins */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBINS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">bin</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cp">#if MORECORE_CONTIGUOUS
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
<span class="cp">#endif
</span>  <span class="n">set_noncontiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
    <span class="n">set_max_fast</span> <span class="p">(</span><span class="n">DEFAULT_MXFAST</span><span class="p">);</span>
  <span class="n">av</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FASTCHUNKS_BIT</span><span class="p">;</span>

  <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">initial_top</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="bins相关"><span class="mr-2">bins相关</span><a href="#bins相关" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#define NBINS             128
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
</span>
<span class="cm">/* addressing -- note that bin_at(0) does not exist */</span>
<span class="cp">#define bin_at(m, i) \
  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \
             - offsetof (struct malloc_chunk, fd))
</span>
<span class="cm">/* analog of ++bin */</span>
<span class="cp">#define next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))
</span>
<span class="cm">/* Reminders about list directionality within bins */</span>
<span class="cp">#define first(b)     ((b)-&gt;fd)
#define last(b)      ((b)-&gt;bk)
</span></pre></table></code></div></div><h2 id="chunk相关"><span class="mr-2">chunk相关</span><a href="#chunk相关" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>chunk2mem：chunk的起始地址转换到用户内存mem地址。chunk起始地址在低地址，所以通过加上2*SIZE_SZ的方式，转换到高地址的mem地址指针<li>mem2chunk：用户内存mem地址转换到chunk的起始地址。用户内存mem地址在高地址，所以通过减去2*SIZE_SZ的方式，转到低地址的chunk的起始地址<li>MIN_CHUNK_SIZE：最小的chunk大小。通过offsetof 函数计算出fd_nextsize 在 malloc_chunk 中的偏移，至少包含mchunk_prev_size、mchunk_size、fd、bk四个地址的空间量。所以64位系统，最小是32字节（4<em>8）；32位系统，最小是16字节（4</em>4）<li>aligned_OK：检查内存是否对齐。64位系统按照16字节对齐，32位系统按照8字节对齐<li>request2size：通过对齐后，实际chunk的大小。如果内存大小小于MINSIZE，则使用MINSIZE空间；否则通过MALLOC_ALIGN_MASK进行字节对齐。</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/* conversion from malloc headers to user pointers, and back */</span>

<span class="cp">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
</span>
<span class="cm">/* The smallest possible chunk */</span>
<span class="cp">#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
</span>
<span class="cm">/* The smallest size we can malloc is an aligned minimal chunk */</span>

<span class="cp">#define MINSIZE  \
  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span>
<span class="cp">#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)
</span>
<span class="cm">/* pad request bytes into a usable size -- internal version */</span>

<span class="cp">#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></pre></table></code></div></div><h1 id="reference">reference</h1><ol><li><a href="https://sploitfun.wordpress.com/tag/ptmalloc/">Understanding glibc malloc</a><li><a href="http://phrack.org/issues/57/8.html">Vudo malloc tricks</a><li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a><li><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">Understanding the GLIBC Heap Implementation</a><li><a href="https://github.com/SignorMercurio/Heap-Tutorials/blob/master/GLibcHeapInternals/GLibcHeap.md">GLibcHeapInternals</a><li><a href="https://www.jianshu.com/p/3ef98e86a913">libc2.26 之后的 Tcache 机制</a><li><a href="https://blog.csdn.net/qq_40890756/article/details/102560506">glibc Tcache机制</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a>, <a href='/categories/basic/'>Basic</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ptmalloc/" class="post-tag no-text-decoration" >ptmalloc</a> <a href="/tags/heap/" class="post-tag no-text-decoration" >heap</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/">程序编译与链接</a><li><a href="/posts/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">高级网络攻防漏洞利用</a><li><a href="/posts/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E9%80%86%E5%90%91/">高级网络攻防逆向</a><li><a href="/posts/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">Linux保护机制</a><li><a href="/posts/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/">栈刷题小结</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/elf/">elf</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/pwnable/">pwnable</a> <a class="post-tag" href="/tags/memory/">memory</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/abi/">abi</a> <a class="post-tag" href="/tags/dram/">dram</a> <a class="post-tag" href="/tags/dynelf/">dynelf</a> <a class="post-tag" href="/tags/fmt/">fmt</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%A0%86%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"><div class="card-body"> <em class="small" data-ts="1662984660" data-df="YYYY-MM-DD" > 2022-09-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>堆利用总结</h3><div class="text-muted small"><p> 安全检测 Double Free检测 该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)的话，就会报出double fre...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"><div class="card-body"> <em class="small" data-ts="1662984900" data-df="YYYY-MM-DD" > 2022-09-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>堆刷题小结</h3><div class="text-muted small"><p> ACTF_2019_message(doubel free + free_hook attack) ACTF_2019_message 简单的double free到message信息储存的区域，实现任意地址写，通过show泄露函数地址 注意程序开启了full reloc，所以不能劫持got表，这里劫持__free_hook 1 2 3 4 5 6 7 8 9 10 11 12 13...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/"><div class="card-body"> <em class="small" data-ts="1664288100" data-df="YYYY-MM-DD" > 2022-09-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>符号解析</h3><div class="text-muted small"><p> 结合源码分析 符号和符号表 在链接器的上下文中，可以定义三种不同的符号 当前模块定义并且能被其他模块引用的全局符号，包括函数和全局变量。 其他模块定义并且被当前模块引用的全局符号，也称为外部符号。 只被当前模块定义和引用的局部符号，包括带static属性的函数和全局变量。 其他变量一般通过栈管理，不生成符号。但是，带static修饰的过程变量却会出现在.symt...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/wargames%E5%88%B7%E9%A2%981/" class="btn btn-outline-primary" prompt="上一篇"><p>wargames刷题[Leviathan]</p></a> <a href="/posts/%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%9D%82%E9%A1%B9/" class="btn btn-outline-primary" prompt="下一篇"><p>攻击方式杂项</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/fengF3ng">fengF3ng</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/elf/">elf</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/pwnable/">pwnable</a> <a class="post-tag" href="/tags/memory/">memory</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/abi/">abi</a> <a class="post-tag" href="/tags/dram/">dram</a> <a class="post-tag" href="/tags/dynelf/">dynelf</a> <a class="post-tag" href="/tags/fmt/">fmt</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
